// This file is autogenerated!
// All changes made will be lost (eventually)!

use sighandler_t;

pub type c_char = i8;
pub type c_long = i64;
pub type c_ulong = u64;
pub type blkcnt64_t = i64;
pub type rlimit64 = ::rlimit;
pub type rlim64_t = ::rlim_t;
pub type ino64_t = ::ino_t;
pub type dirent64 = ::dirent;
pub type stat64 = ::stat;
pub type statfs64 = ::statfs;
pub type statvfs64 = ::statvfs;
pub type idtype_t = ::c_uint;
pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
pub const RLIM_INFINITY: ::rlim_t = !0;

pub type Elf32_Half = u16;
pub type Elf32_Word = u32;
pub type Elf32_Off = u32;
pub type Elf32_Addr = u32;

pub type Elf64_Half = u16;
pub type Elf64_Word = u32;
pub type Elf64_Off = u64;
pub type Elf64_Addr = u64;
pub type Elf64_Xword = u64;

s! {
    pub struct Elf32_Phdr {
        pub p_type: Elf32_Word,
        pub p_offset: Elf32_Off,
        pub p_vaddr: Elf32_Addr,
        pub p_paddr: Elf32_Addr,
        pub p_filesz: Elf32_Word,
        pub p_memsz: Elf32_Word,
        pub p_flags: Elf32_Word,
        pub p_align: Elf32_Word,
    }

    pub struct Elf64_Phdr {
        pub p_type: Elf64_Word,
        pub p_flags: Elf64_Word,
        pub p_offset: Elf64_Off,
        pub p_vaddr: Elf64_Addr,
        pub p_paddr: Elf64_Addr,
        pub p_filesz: Elf64_Xword,
        pub p_memsz: Elf64_Xword,
        pub p_align: Elf64_Xword,
    }
}

s! {
    pub struct dl_phdr_info {
        #[cfg(target_pointer_width = "64")]
        pub dlpi_addr: Elf64_Addr,
        #[cfg(target_pointer_width = "32")]
        pub dlpi_addr: Elf32_Addr,

        pub dlpi_name: *const ::c_char,

        #[cfg(target_pointer_width = "64")]
        pub dlpi_phdr: *const Elf64_Phdr,
        #[cfg(target_pointer_width = "32")]
        pub dlpi_phdr: *const Elf32_Phdr,

        #[cfg(target_pointer_width = "64")]
        pub dlpi_phnum: Elf64_Half,
        #[cfg(target_pointer_width = "32")]
        pub dlpi_phnum: Elf32_Half,

        pub dlpi_adds: ::c_ulonglong,
        pub dlpi_subs: ::c_ulonglong,
        pub dlpi_tls_modid: ::size_t,
        pub dlpi_tls_data: *mut ::c_void,
    }
}

f! {
    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {
        if ((*cmsg).cmsg_len as usize) < ::mem::size_of::<cmsghdr>() {
            return 0 as *mut cmsghdr;
        };
        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;
        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
        if (next.offset(1)) as usize > max ||
            next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max {
            0 as *mut cmsghdr
        } else {
            next as *mut cmsghdr
        }
    }
}

align_const! {
    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
        size: [0; 16],
    };
    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
        size: [0; 12],
    };
    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
        size: [0; 12],
    };
}
s_no_extra_traits! {
    pub struct ifreq {
        pub ifru_addr: ::sockaddr,
        pub ifru_dstaddr: ::sockaddr,
        pub ifru_broadaddr: ::sockaddr,
        pub ifru_netmask: ::sockaddr,
        pub ifru_hwaddr: ::sockaddr,
        pub ifru_flags: ::c_short,
        pub ifru_ivalue: ::c_int,
        pub ifru_mtu: ::c_int,
        pub ifru_map: ::ifmap,
        pub ifru_slave: [::c_char; 16],
        pub ifru_newname: [::c_char; 16],
        pub ifru_data: *mut ::c_char,
    }
}

impl ::fmt::Debug for ifreq {
    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
        f.debug_struct("ifreq").finish()
    }
}

safe_f! {
    pub {const} fn makedev(major: ::c_uint, minor: ::c_uint) -> ::dev_t {
        let major = major as ::dev_t;
        let minor = minor as ::dev_t;
        let mut dev = 0;
        dev |= (major & 0x00000fff) << 8;
        dev |= (major & 0xfffff000) << 32;
        dev |= (minor & 0x000000ff) << 0;
        dev |= (minor & 0xffffff00) << 12;
        dev
    }
}

f! {
    pub fn major(dev: ::dev_t) -> ::c_uint {
        let mut major = 0;
        major |= (dev & 0x00000000000fff00) >> 8;
        major |= (dev & 0xfffff00000000000) >> 32;
        major as ::c_uint
    }

    pub fn minor(dev: ::dev_t) -> ::c_uint {
        let mut minor = 0;
        minor |= (dev & 0x00000000000000ff) >> 0;
        minor |= (dev & 0x00000ffffff00000) >> 12;
        minor as ::c_uint
    }
}

// abi-bits/access.h

// abi-bits/auxv.h
pub const AT_NULL: ::c_int = 0;
pub const AT_PHDR: ::c_int = 3;
pub const AT_PHENT: ::c_int = 4;
pub const AT_PHNUM: ::c_int = 5;
pub const AT_ENTRY: ::c_int = 9;
pub const AT_EXECPATH: ::c_int = 15;
pub const AT_SECURE: ::c_int = 23;
pub const AT_RANDOM: ::c_int = 25;
pub const AT_EXECFN: ::c_int = 31;

// abi-bits/blkcnt_t.h
pub type blkcnt_t = ::c_long;

// abi-bits/blksize_t.h
pub type blksize_t = ::c_long;

// abi-bits/clockid_t.h

// abi-bits/dev_t.h
pub type dev_t = u64;

// abi-bits/epoll.h
pub const EPOLL_CLOEXEC: ::c_int = 1;

// abi-bits/errno.h
pub const EDOM: ::c_int = 1;
pub const EILSEQ: ::c_int = 2;
pub const ERANGE: ::c_int = 3;
pub const E2BIG: ::c_int = 1001;
pub const EACCES: ::c_int = 1002;
pub const EADDRINUSE: ::c_int = 1003;
pub const EADDRNOTAVAIL: ::c_int = 1004;
pub const EAFNOSUPPORT: ::c_int = 1005;
pub const EAGAIN: ::c_int = 1006;
pub const EALREADY: ::c_int = 1007;
pub const EBADF: ::c_int = 1008;
pub const EBADMSG: ::c_int = 1009;
pub const EBUSY: ::c_int = 1010;
pub const ECANCELED: ::c_int = 1011;
pub const ECHILD: ::c_int = 1012;
pub const ECONNABORTED: ::c_int = 1013;
pub const ECONNREFUSED: ::c_int = 1014;
pub const ECONNRESET: ::c_int = 1015;
pub const EDEADLK: ::c_int = 1016;
pub const EDESTADDRREQ: ::c_int = 1017;
pub const EDQUOT: ::c_int = 1018;
pub const EEXIST: ::c_int = 1019;
pub const EFAULT: ::c_int = 1020;
pub const EFBIG: ::c_int = 1021;
pub const EHOSTUNREACH: ::c_int = 1022;
pub const EIDRM: ::c_int = 1023;
pub const EINPROGRESS: ::c_int = 1024;
pub const EINTR: ::c_int = 1025;
pub const EINVAL: ::c_int = 1026;
pub const EIO: ::c_int = 1027;
pub const EISCONN: ::c_int = 1028;
pub const EISDIR: ::c_int = 1029;
pub const ELOOP: ::c_int = 1030;
pub const EMFILE: ::c_int = 1031;
pub const EMLINK: ::c_int = 1032;
pub const EMSGSIZE: ::c_int = 1034;
pub const EMULTIHOP: ::c_int = 1035;
pub const ENAMETOOLONG: ::c_int = 1036;
pub const ENETDOWN: ::c_int = 1037;
pub const ENETRESET: ::c_int = 1038;
pub const ENETUNREACH: ::c_int = 1039;
pub const ENFILE: ::c_int = 1040;
pub const ENOBUFS: ::c_int = 1041;
pub const ENODEV: ::c_int = 1042;
pub const ENOENT: ::c_int = 1043;
pub const ENOEXEC: ::c_int = 1044;
pub const ENOLCK: ::c_int = 1045;
pub const ENOLINK: ::c_int = 1046;
pub const ENOMEM: ::c_int = 1047;
pub const ENOMSG: ::c_int = 1048;
pub const ENOPROTOOPT: ::c_int = 1049;
pub const ENOSPC: ::c_int = 1050;
pub const ENOSYS: ::c_int = 1051;
pub const ENOTCONN: ::c_int = 1052;
pub const ENOTDIR: ::c_int = 1053;
pub const ENOTEMPTY: ::c_int = 1054;
pub const ENOTRECOVERABLE: ::c_int = 1055;
pub const ENOTSOCK: ::c_int = 1056;
pub const ENOTSUP: ::c_int = 1057;
pub const ENOTTY: ::c_int = 1058;
pub const ENXIO: ::c_int = 1059;
pub const EOPNOTSUPP: ::c_int = 1060;
pub const EOVERFLOW: ::c_int = 1061;
pub const EOWNERDEAD: ::c_int = 1062;
pub const EPERM: ::c_int = 1063;
pub const EPIPE: ::c_int = 1064;
pub const EPROTO: ::c_int = 1065;
pub const EPROTONOSUPPORT: ::c_int = 1066;
pub const EPROTOTYPE: ::c_int = 1067;
pub const EROFS: ::c_int = 1068;
pub const ESPIPE: ::c_int = 1069;
pub const ESRCH: ::c_int = 1070;
pub const ESTALE: ::c_int = 1071;
pub const ETIMEDOUT: ::c_int = 1072;
pub const ETXTBSY: ::c_int = 1073;
pub const EWOULDBLOCK: ::c_int = EAGAIN;
pub const EXDEV: ::c_int = 1075;
pub const ENODATA: ::c_int = 1076;
pub const ETIME: ::c_int = 1077;
pub const ENOKEY: ::c_int = 1078;
pub const ESHUTDOWN: ::c_int = 1079;
pub const EHOSTDOWN: ::c_int = 1080;
pub const EBADFD: ::c_int = 1081;
pub const ENOMEDIUM: ::c_int = 1082;
pub const ENOTBLK: ::c_int = 1083;
pub const ENONET: ::c_int = 1084;
pub const EPFNOSUPPORT: ::c_int = 1085;
pub const ESOCKTNOSUPPORT: ::c_int = 1086;
pub const ESTRPIPE: ::c_int = 1087;
pub const EREMOTEIO: ::c_int = 1088;
pub const ERFKILL: ::c_int = 1089;
pub const EBADR: ::c_int = 1090;
pub const EUNATCH: ::c_int = 1091;
pub const EMEDIUMTYPE: ::c_int = 1092;
pub const EREMOTE: ::c_int = 1093;
pub const EKEYREJECTED: ::c_int = 1094;
pub const EUCLEAN: ::c_int = 1095;
pub const EBADSLT: ::c_int = 1096;
pub const ENOANO: ::c_int = 1097;
pub const ENOCSI: ::c_int = 1098;
pub const ENOSTR: ::c_int = 1099;
pub const ETOOMANYREFS: ::c_int = 1100;
pub const ENOPKG: ::c_int = 1101;
pub const EKEYREVOKED: ::c_int = 1102;
pub const EXFULL: ::c_int = 1103;
pub const ELNRNG: ::c_int = 1104;
pub const ENOTUNIQ: ::c_int = 1105;
pub const ERESTART: ::c_int = 1106;
pub const EUSERS: ::c_int = 1107;
pub const ECHRNG: ::c_int = 1108;
pub const ELIBBAD: ::c_int = 1109;
pub const EL2HLT: ::c_int = 1110;
pub const EL3HLT: ::c_int = 1111;
pub const EKEYEXPIRED: ::c_int = 1112;
pub const ECOMM: ::c_int = 1113;
pub const EBADE: ::c_int = 1114;
pub const EHWPOISON: ::c_int = 1115;
pub const EBADRQC: ::c_int = 1116;
pub const EIEIO: ::c_int = 1524152434;

// abi-bits/fcntl.h
pub const O_PATH: ::c_int = 0o10000000;
pub const O_ACCMODE: ::c_int = 0o3 | O_PATH;
pub const O_CREAT: ::c_int = 0o100;
pub const O_EXCL: ::c_int = 0o200;
pub const O_NOCTTY: ::c_int = 0o400;
pub const O_TRUNC: ::c_int = 0o1000;
pub const O_APPEND: ::c_int = 0o2000;
pub const O_NONBLOCK: ::c_int = 0o4000;
pub const O_DSYNC: ::c_int = 0o10000;
pub const O_ASYNC: ::c_int = 0o20000;
pub const O_DIRECT: ::c_int = 0o40000;
pub const O_DIRECTORY: ::c_int = 0o200000;
pub const O_NOFOLLOW: ::c_int = 0o400000;
pub const O_CLOEXEC: ::c_int = 0o2000000;
pub const O_SYNC: ::c_int = 0o4010000;
pub const O_RSYNC: ::c_int = 0o4010000;
pub const O_LARGEFILE: ::c_int = 0o100000;
pub const O_NOATIME: ::c_int = 0o1000000;
pub const O_TMPFILE: ::c_int = 0o20000000;
pub const O_EXEC: ::c_int = O_PATH;
pub const O_SEARCH: ::c_int = O_PATH;
pub const F_SETOWN: ::c_int = 8;
pub const F_GETOWN: ::c_int = 9;
pub const F_SETSIG: ::c_int = 10;
pub const F_GETSIG: ::c_int = 11;
pub const F_GETLK: ::c_int = 5;
pub const F_SETLK: ::c_int = 6;
pub const F_SETLK64: ::c_int = F_SETLK;
pub const F_SETLKW: ::c_int = 7;
pub const F_SETLKW64: ::c_int = F_SETLKW;
pub const F_SETOWN_EX: ::c_int = 15;
pub const F_GETOWN_EX: ::c_int = 16;
pub const F_GETOWNER_UIDS: ::c_int = 17;
pub const F_RDLCK: ::c_int = 0;
pub const F_WRLCK: ::c_int = 1;
pub const F_UNLCK: ::c_int = 2;
pub const AT_EACCESS: ::c_int = 0x200;
pub const AT_STATX_SYNC_AS_STAT: ::c_int = 0x0000;
pub const AT_STATX_FORCE_SYNC: ::c_int = 0x2000;
pub const AT_STATX_DONT_SYNC: ::c_int = 0x4000;
pub const AT_STATX_SYNC_TYPE: ::c_int = 0x6000;
pub const F_OWNER_TID: ::c_int = 0;
pub const POSIX_FADV_DONTNEED: ::c_int = 4;
pub const POSIX_FADV_NOREUSE: ::c_int = 5;
s! {
    pub struct f_owner_ex {
        pub r#type: ::c_int,
        pub pid: ::pid_t,
    }
}

// abi-bits/fsblkcnt_t.h
pub type fsblkcnt_t = u64;

// abi-bits/fsfilcnt_t.h
pub type fsfilcnt_t = u64;

// abi-bits/gid_t.h

// abi-bits/in.h
pub const SOCK_STREAM: ::c_int = 1;
pub const SOCK_DGRAM: ::c_int = 2;
pub const SOCK_SEQPACKET: ::c_int = 5;
pub const SOCK_DCCP: ::c_int = 6;
pub const SOCK_PACKET: ::c_int = 10;
pub const SOCK_NONBLOCK: ::c_int = 0o4000;
pub const PF_LOCAL: ::c_int = 1;
pub const PF_FILE: ::c_int = PF_LOCAL;
pub const PF_IB: ::c_int = 27;
pub const PF_MPLS: ::c_int = 28;
pub const PF_NFC: ::c_int = 39;
pub const PF_VSOCK: ::c_int = 40;
pub const PF_KCM: ::c_int = 41;
pub const PF_QIPCRTR: ::c_int = 42;
pub const PF_SMC: ::c_int = 43;
pub const PF_XDP: ::c_int = 44;
pub const PF_MAX: ::c_int = 45;
pub const AF_LOCAL: ::c_int = PF_LOCAL;
pub const AF_FILE: ::c_int = AF_LOCAL;
pub const AF_IB: ::c_int = PF_IB;
pub const AF_MPLS: ::c_int = PF_MPLS;
pub const AF_NFC: ::c_int = PF_NFC;
pub const AF_VSOCK: ::c_int = PF_VSOCK;
pub const AF_KCM: ::c_int = PF_KCM;
pub const AF_QIPCRTR: ::c_int = PF_QIPCRTR;
pub const AF_SMC: ::c_int = PF_SMC;
pub const AF_XDP: ::c_int = PF_XDP;
pub const AF_MAX: ::c_int = PF_MAX;
pub const SO_REUSEADDR: ::c_int = 2;
pub const SO_TYPE: ::c_int = 3;
pub const SO_ERROR: ::c_int = 4;
pub const SO_DONTROUTE: ::c_int = 5;
pub const SO_BROADCAST: ::c_int = 6;
pub const SO_SNDBUF: ::c_int = 7;
pub const SO_RCVBUF: ::c_int = 8;
pub const SO_KEEPALIVE: ::c_int = 9;
pub const SO_OOBINLINE: ::c_int = 10;
pub const SO_NO_CHECK: ::c_int = 11;
pub const SO_PRIORITY: ::c_int = 12;
pub const SO_LINGER: ::c_int = 13;
pub const SO_BSDCOMPAT: ::c_int = 14;
pub const SO_REUSEPORT: ::c_int = 15;
pub const SO_PASSCRED: ::c_int = 16;
pub const SO_PEERCRED: ::c_int = 17;
pub const SO_RCVLOWAT: ::c_int = 18;
pub const SO_SNDLOWAT: ::c_int = 19;
pub const SO_ACCEPTCONN: ::c_int = 30;
pub const SO_PEERSEC: ::c_int = 31;
pub const SO_SNDBUFFORCE: ::c_int = 32;
pub const SO_RCVBUFFORCE: ::c_int = 33;
pub const SO_PROTOCOL: ::c_int = 38;
pub const SO_DOMAIN: ::c_int = 39;
pub const SO_RCVTIMEO: ::c_int = 20;
pub const SO_SNDTIMEO: ::c_int = 21;
pub const SO_TIMESTAMP: ::c_int = 29;
pub const SO_TIMESTAMPNS: ::c_int = 35;
pub const SO_TIMESTAMPING: ::c_int = 37;
pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
pub const SO_BINDTODEVICE: ::c_int = 25;
pub const SO_ATTACH_FILTER: ::c_int = 26;
pub const SO_DETACH_FILTER: ::c_int = 27;
pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
pub const SO_PEERNAME: ::c_int = 28;
pub const SO_PASSSEC: ::c_int = 34;
pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
pub const SO_MARK: ::c_int = 36;
pub const SCM_TIMESTAMPING: ::c_int = SO_TIMESTAMPING;
pub const SO_RXQ_OVFL: ::c_int = 40;
pub const SO_WIFI_STATUS: ::c_int = 41;
pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
pub const SO_PEEK_OFF: ::c_int = 42;
pub const SO_NOFCS: ::c_int = 43;
pub const SO_LOCK_FILTER: ::c_int = 44;
pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
pub const SO_BUSY_POLL: ::c_int = 46;
pub const SO_MAX_PACING_RATE: ::c_int = 47;
pub const SO_BPF_EXTENSIONS: ::c_int = 48;
pub const SO_INCOMING_CPU: ::c_int = 49;
pub const SO_ATTACH_BPF: ::c_int = 50;
pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
pub const SO_ATTACH_REUSEPORT_CBPF: ::c_int = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: ::c_int = 52;
pub const SO_CNX_ADVICE: ::c_int = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: ::c_int = 54;
pub const SO_MEMINFO: ::c_int = 55;
pub const SO_INCOMING_NAPI_ID: ::c_int = 56;
pub const SO_COOKIE: ::c_int = 57;
pub const SCM_TIMESTAMPING_PKTINFO: ::c_int = 58;
pub const SO_PEERGROUPS: ::c_int = 59;
pub const SO_ZEROCOPY: ::c_int = 60;
pub const SO_TXTIME: ::c_int = 61;
pub const SCM_TXTIME: ::c_int = SO_TXTIME;
pub const SO_BINDTOIFINDEX: ::c_int = 62;
pub const SO_DETACH_REUSEPORT_BPF: ::c_int = 68;
pub const SOL_SOCKET: ::c_int = 1;
pub const SOL_RXRPC: ::c_int = 272;
pub const SOL_PPPOL2TP: ::c_int = 273;
pub const SOL_PNPIPE: ::c_int = 275;
pub const SOL_RDS: ::c_int = 276;
pub const SOL_IUCV: ::c_int = 277;
pub const SOL_CAIF: ::c_int = 278;
pub const SOL_NFC: ::c_int = 280;
pub const SOL_KCM: ::c_int = 281;
pub const SOL_TLS: ::c_int = 282;
pub const SOL_XDP: ::c_int = 283;
pub const SOMAXCONN: ::c_int = 128;
pub const MSG_PROXY: ::c_int = 0x0010;
pub const MSG_BATCH: ::c_int = 0x40000;
pub const MSG_ZEROCOPY: ::c_int = 0x4000000;
pub const INET_ADDRSTRLEN: ::c_int = 16;
pub const INET6_ADDRSTRLEN: ::c_int = 46;
pub const IPPORT_RESERVED: ::c_int = 1024;
pub const IPPROTO_MAX: ::c_int = 256;
pub const IPV6_JOIN_GROUP: ::c_int = 20;
pub const IPV6_LEAVE_GROUP: ::c_int = 21;
pub type socklen_t = ::c_uint;
s! {
    pub struct iovec {
        pub iov_base: *mut ::c_void,
        pub iov_len: usize,
    }
}
s! {
    pub struct msghdr {
        pub msg_name: *mut ::c_void,
        pub msg_namelen: ::socklen_t,
        pub msg_iov: *mut ::iovec,
        pub msg_iovlen: ::size_t,
        pub msg_control: *mut ::c_void,
        pub msg_controllen: ::size_t,
        pub msg_flags: ::c_int,
    }
    pub struct cmsghdr {
        pub cmsg_len: ::size_t,
        pub cmsg_level: ::c_int,
        pub cmsg_type: ::c_int,
    }
    pub struct ipv6_mreq {
        pub ipv6mr_multiaddr: ::in6_addr,
        pub ipv6mr_interface: ::c_uint,
    }
    pub struct in6_pktinfo {
        pub ipi6_addr: ::in6_addr,
        pub ipi6_ifindex: u32,
    }
    pub struct group_req {
        pub gr_interface: u32,
        pub gr_group: ::sockaddr_storage,
    }
    pub struct group_source_req {
        pub gsr_interface: u32,
        pub gsr_group: ::sockaddr_storage,
        pub gsr_source: ::sockaddr_storage,
    }
}

// abi-bits/ino_t.h
pub type ino_t = ::c_long;

// abi-bits/inotify.h
pub const IN_CLOEXEC: ::c_int = 1;
pub const IN_NONBLOCK: ::c_int = 2;

// abi-bits/ioctls.h
pub const TIOCEXCL: ::c_int = 0x540C;
pub const TIOCNXCL: ::c_int = 0x540D;
pub const SIOCPROTOPRIVATE: ::c_int = 0x89E0;
pub const SIOCGSTAMP: ::c_int = 0x8906;
pub const SIOCGIFNAME: ::c_int = 0x8910;
pub const SIOCGIFCONF: ::c_int = 0x8912;
pub const SIOCGIFFLAGS: ::c_int = 0x8913;
pub const SIOCSIFFLAGS: ::c_int = 0x8914;
pub const SIOCGIFADDR: ::c_int = 0x8915;
pub const SIOCGIFINDEX: ::c_int = 0x8933;
pub const SIOCATMARK: ::c_int = 0x8905;
pub const SIOCGIFHWADDR: ::c_int = 0x8927;
pub const SIOCGIFBRDADDR: ::c_int = 0x8919;
pub const SIOCGIFNETMASK: ::c_int = 0x891B;

// abi-bits/mode_t.h
pub type mode_t = ::c_int;

// abi-bits/mqueue.h
s! {
    pub struct mq_attr {
        pub mq_flags: ::c_long,
        pub mq_maxmsg: ::c_long,
        pub mq_msgsize: ::c_long,
        pub mq_curmsgs: ::c_long,
        pub __pad: [::c_long; 4],
    }
}

// abi-bits/msg.h
pub const IPC_CREAT: ::c_int = 0o1000;
pub const IPC_EXCL: ::c_int = 0o2000;
pub const IPC_NOWAIT: ::c_int = 0o4000;
pub const IPC_RMID: ::c_int = 0;
pub const IPC_SET: ::c_int = 1;
pub const IPC_STAT: ::c_int = 2;
pub const IPC_INFO: ::c_int = 3;
pub const IPC_64: ::c_int = 0;
s! {
    pub struct ipc64_perm {
        pub __ipc_perm_key: ::key_t,
        pub uid: ::uid_t,
        pub gid: ::gid_t,
        pub cuid: ::uid_t,
        pub cgid: ::gid_t,
        pub mode: ::mode_t,
        pub __ipc_perm_seq: ::c_short,
        pub __pad: ::c_short,
        pub __unused: [::c_ulong; 2],
    }
}
extern "C" {
    pub fn ftok(__path: *const ::c_char, __proj_id: ::c_int) -> ::key_t;
}
pub type time_t = ::c_long;
pub type msglen_t = ::c_ulong;
pub type msgqnum_t = ::c_ulong;
s! {
    pub struct msqid64_ds {
        pub msg_perm: ::ipc64_perm,
        pub msg_stime: ::time_t,
        pub msg_rtime: ::time_t,
        pub msg_ctime: ::time_t,
        pub msg_cbytes: ::c_ulong,
        pub msg_qnum: ::msgqnum_t,
        pub msg_qbytes: ::msglen_t,
        pub msg_lspid: ::pid_t,
        pub msg_lrpid: ::pid_t,
        pub __unused: [::c_ulong; 2],
    }
}

// abi-bits/nlink_t.h
pub type nlink_t = ::c_int;

// abi-bits/packet.h
pub const PACKET_HOST: ::c_int = 0;

// abi-bits/pid_t.h

// abi-bits/poll.h
pub const POLLWRNORM: ::c_short = 0x80;
pub const POLLWRBAND: ::c_short = 0x200;

// abi-bits/ptrace.h
pub const PTRACE_PEEKTEXT: ::c_int = 1;
pub const PTRACE_PEEKDATA: ::c_int = 2;
pub const PTRACE_PEEKUSER: ::c_int = 3;
pub const PTRACE_POKETEXT: ::c_int = 4;
pub const PTRACE_POKEDATA: ::c_int = 5;
pub const PTRACE_POKEUSER: ::c_int = 6;
pub const PTRACE_CONT: ::c_int = 7;
pub const PTRACE_KILL: ::c_int = 8;
pub const PTRACE_SINGLESTEP: ::c_int = 9;
pub const PTRACE_GETREGS: ::c_int = 12;
pub const PTRACE_SETREGS: ::c_int = 13;
pub const PTRACE_GETFPREGS: ::c_int = 14;
pub const PTRACE_SETFPREGS: ::c_int = 15;
pub const PTRACE_ATTACH: ::c_int = 16;
pub const PTRACE_DETACH: ::c_int = 17;
pub const PTRACE_GETFPXREGS: ::c_int = 18;
pub const PTRACE_SETFPXREGS: ::c_int = 19;
pub const PTRACE_SYSCALL: ::c_int = 24;
pub const PTRACE_SETOPTIONS: ::c_int = 0x4200;
pub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;
pub const PTRACE_GETSIGINFO: ::c_int = 0x4202;
pub const PTRACE_SETSIGINFO: ::c_int = 0x4203;
pub const PTRACE_GETREGSET: ::c_int = 0x4204;
pub const PTRACE_SETREGSET: ::c_int = 0x4205;
pub const PTRACE_SEIZE: ::c_int = 0x4206;
pub const PTRACE_INTERRUPT: ::c_int = 0x4207;
pub const PTRACE_LISTEN: ::c_int = 0x4208;
pub const PTRACE_PEEKSIGINFO: ::c_int = 0x4209;
pub const PTRACE_GETSIGMASK: ::c_int = 0x420A;
pub const PTRACE_SETSIGMASK: ::c_int = 0x420B;
pub const PTRACE_SECCOMP_GET_FILTER: ::c_int = 0x420C;
pub const PTRACE_EVENT_STOP: ::c_int = 128;
pub const PTRACE_PEEKSIGINFO_SHARED: ::c_int = 1;

// abi-bits/reboot.h
pub const RB_AUTOBOOT: ::c_int = 0x01234567;
pub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123;
pub const RB_ENABLE_CAD: ::c_int = 0x89abcdef;
pub const RB_DISABLE_CAD: ::c_int = 0;
pub const RB_POWER_OFF: ::c_int = 0x4321fedc;
pub const RB_SW_SUSPEND: ::c_int = 0xd000fce2;
pub const RB_KEXEC: ::c_int = 0x45584543;

// abi-bits/resource.h
pub const RUSAGE_CHILDREN: ::c_int = 1;
pub const RLIMIT_CPU: ::c_int = 0;
pub const RLIMIT_FSIZE: ::c_int = 1;
pub const RLIMIT_DATA: ::c_int = 2;
pub const RLIMIT_STACK: ::c_int = 3;
pub const RLIMIT_CORE: ::c_int = 4;
pub const RLIMIT_RSS: ::c_int = 5;
pub const RLIMIT_NPROC: ::c_int = 6;
pub const RLIMIT_NOFILE: ::c_int = 7;
pub const RLIMIT_MEMLOCK: ::c_int = 8;
pub const RLIMIT_AS: ::c_int = 9;
pub const RLIMIT_LOCKS: ::c_int = 10;
pub const RLIMIT_SIGPENDING: ::c_int = 11;
pub const RLIMIT_MSGQUEUE: ::c_int = 12;
pub const RLIMIT_NICE: ::c_int = 13;
pub const RLIMIT_RTPRIO: ::c_int = 14;
pub const RLIMIT_RTTIME: ::c_int = 15;
pub const RLIMIT_NLIMITS: ::c_int = 16;
pub type suseconds_t = ::c_long;
s! {
    pub struct timeval {
        pub tv_sec: ::time_t,
        pub tv_usec: ::suseconds_t,
    }
    pub struct rusage {
        pub ru_utime: ::timeval,
        pub ru_stime: ::timeval,
        pub ru_maxrss: ::c_long,
        pub ru_ixrss: ::c_long,
        pub ru_idrss: ::c_long,
        pub ru_isrss: ::c_long,
        pub ru_minflt: ::c_long,
        pub ru_majflt: ::c_long,
        pub ru_nswap: ::c_long,
        pub ru_inblock: ::c_long,
        pub ru_oublock: ::c_long,
        pub ru_msgsnd: ::c_long,
        pub ru_msgrcv: ::c_long,
        pub ru_nsignals: ::c_long,
        pub ru_nvcsw: ::c_long,
        pub ru_nivcsw: ::c_long,
    }
}

// abi-bits/seek-whence.h
pub const SEEK_DATA: ::c_int = 3;
pub const SEEK_HOLE: ::c_int = 4;

// abi-bits/shm.h
pub const _POSIX_VERSION: ::c_long = 200809;
pub const _XOPEN_VERSION: ::c_int = 700;
pub const _POSIX_JOB_CONTROL: ::c_int = 1;
pub const _POSIX_SAVED_IDS: ::c_int = 1;
pub const _POSIX_SHELL: ::c_int = 1;
pub const _POSIX_MONOTONIC_CLOCK: ::c_int = 0;
pub const _CS_PATH: ::c_int = 0;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: ::c_int = 1;
pub const _CS_GNU_LIBC_VERSION: ::c_int = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::c_int = 3;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: ::c_int = 4;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: ::c_int = 5;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::c_int = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::c_int = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::c_int = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::c_int = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::c_int = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::c_int = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::c_int = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::c_int = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::c_int = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::c_int = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::c_int = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::c_int = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::c_int = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::c_int = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::c_int = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::c_int = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::c_int = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::c_int = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::c_int = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::c_int = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::c_int = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::c_int = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::c_int = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::c_int = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::c_int = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::c_int = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::c_int = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::c_int = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::c_int = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::c_int = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::c_int = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::c_int = 1147;
pub const _CS_V6_ENV: ::c_int = 1148;
pub const _CS_V7_ENV: ::c_int = 1149;
pub const F_LOCK: ::c_int = 1;
pub const F_TEST: ::c_int = 2;
pub const F_TLOCK: ::c_int = 3;
pub const F_ULOCK: ::c_int = 4;
pub const _PC_LINK_MAX: ::c_int = 0;
pub const _PC_MAX_CANON: ::c_int = 1;
pub const _PC_MAX_INPUT: ::c_int = 2;
pub const _PC_NAME_MAX: ::c_int = 3;
pub const _PC_PATH_MAX: ::c_int = 4;
pub const _PC_PIPE_BUF: ::c_int = 5;
pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
pub const _PC_NO_TRUNC: ::c_int = 7;
pub const _PC_VDISABLE: ::c_int = 8;
pub const _PC_FILESIZEBITS: ::c_int = 9;
pub const _PC_SYMLINK_MAX: ::c_int = 10;
pub const _SC_ARG_MAX: ::c_int = 0;
pub const _SC_CHILD_MAX: ::c_int = 1;
pub const _SC_CLK_TCK: ::c_int = 2;
pub const _SC_NGROUPS_MAX: ::c_int = 3;
pub const _SC_OPEN_MAX: ::c_int = 4;
pub const _SC_STREAM_MAX: ::c_int = 5;
pub const _SC_TZNAME_MAX: ::c_int = 6;
pub const _SC_JOB_CONTROL: ::c_int = 7;
pub const _SC_SAVED_IDS: ::c_int = 8;
pub const _SC_REALTIME_SIGNALS: ::c_int = 9;
pub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;
pub const _SC_TIMERS: ::c_int = 11;
pub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;
pub const _SC_PRIORITIZED_IO: ::c_int = 13;
pub const _SC_SYNCHRONIZED_IO: ::c_int = 14;
pub const _SC_FSYNC: ::c_int = 15;
pub const _SC_MAPPED_FILES: ::c_int = 16;
pub const _SC_MEMLOCK: ::c_int = 17;
pub const _SC_MEMLOCK_RANGE: ::c_int = 18;
pub const _SC_MEMORY_PROTECTION: ::c_int = 19;
pub const _SC_MESSAGE_PASSING: ::c_int = 20;
pub const _SC_SEMAPHORES: ::c_int = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;
pub const _SC_AIO_LISTIO_MAX: ::c_int = 23;
pub const _SC_AIO_MAX: ::c_int = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;
pub const _SC_DELAYTIMER_MAX: ::c_int = 26;
pub const _SC_MQ_OPEN_MAX: ::c_int = 27;
pub const _SC_MQ_PRIO_MAX: ::c_int = 28;
pub const _SC_VERSION: ::c_int = 29;
pub const _SC_PAGE_SIZE: ::c_int = 30;
pub const _SC_PAGESIZE: ::c_int = _SC_PAGE_SIZE;
pub const _SC_RTSIG_MAX: ::c_int = 31;
pub const _SC_SEM_NSEMS_MAX: ::c_int = 32;
pub const _SC_SEM_VALUE_MAX: ::c_int = 33;
pub const _SC_SIGQUEUE_MAX: ::c_int = 34;
pub const _SC_TIMER_MAX: ::c_int = 35;
pub const _SC_BC_BASE_MAX: ::c_int = 36;
pub const _SC_BC_DIM_MAX: ::c_int = 37;
pub const _SC_BC_SCALE_MAX: ::c_int = 38;
pub const _SC_BC_STRING_MAX: ::c_int = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;
pub const _SC_EXPR_NEST_MAX: ::c_int = 42;
pub const _SC_LINE_MAX: ::c_int = 43;
pub const _SC_RE_DUP_MAX: ::c_int = 44;
pub const _SC_2_VERSION: ::c_int = 46;
pub const _SC_2_C_BIND: ::c_int = 47;
pub const _SC_2_C_DEV: ::c_int = 48;
pub const _SC_2_FORT_DEV: ::c_int = 49;
pub const _SC_2_FORT_RUN: ::c_int = 50;
pub const _SC_2_SW_DEV: ::c_int = 51;
pub const _SC_2_LOCALEDEF: ::c_int = 52;
pub const _SC_IOV_MAX: ::c_int = 60;
pub const _SC_UIO_MAXIOV: ::c_int = _SC_IOV_MAX;
pub const _SC_THREADS: ::c_int = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;
pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
pub const _SC_TTY_NAME_MAX: ::c_int = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;
pub const _SC_THREAD_KEYS_MAX: ::c_int = 74;
pub const _SC_THREAD_STACK_MIN: ::c_int = 75;
pub const _SC_THREAD_THREADS_MAX: ::c_int = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 82;
pub const _SC_NPROCESSORS_CONF: ::c_int = 83;
pub const _SC_NPROCESSORS_ONLN: ::c_int = 84;
pub const _SC_PHYS_PAGES: ::c_int = 85;
pub const _SC_AVPHYS_PAGES: ::c_int = 86;
pub const _SC_ATEXIT_MAX: ::c_int = 87;
pub const _SC_PASS_MAX: ::c_int = 88;
pub const _SC_XOPEN_VERSION: ::c_int = 89;
pub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;
pub const _SC_XOPEN_UNIX: ::c_int = 91;
pub const _SC_XOPEN_CRYPT: ::c_int = 92;
pub const _SC_XOPEN_ENH_I18N: ::c_int = 93;
pub const _SC_XOPEN_SHM: ::c_int = 94;
pub const _SC_2_CHAR_TERM: ::c_int = 95;
pub const _SC_2_UPE: ::c_int = 97;
pub const _SC_XOPEN_XPG2: ::c_int = 98;
pub const _SC_XOPEN_XPG3: ::c_int = 99;
pub const _SC_XOPEN_XPG4: ::c_int = 100;
pub const _SC_NZERO: ::c_int = 109;
pub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;
pub const _SC_XBS5_LP64_OFF64: ::c_int = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;
pub const _SC_XOPEN_LEGACY: ::c_int = 129;
pub const _SC_XOPEN_REALTIME: ::c_int = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;
pub const _SC_ADVISORY_INFO: ::c_int = 132;
pub const _SC_BARRIERS: ::c_int = 133;
pub const _SC_CLOCK_SELECTION: ::c_int = 137;
pub const _SC_CPUTIME: ::c_int = 138;
pub const _SC_THREAD_CPUTIME: ::c_int = 139;
pub const _SC_MONOTONIC_CLOCK: ::c_int = 149;
pub const _SC_READER_WRITER_LOCKS: ::c_int = 153;
pub const _SC_SPIN_LOCKS: ::c_int = 154;
pub const _SC_REGEXP: ::c_int = 155;
pub const _SC_SHELL: ::c_int = 157;
pub const _SC_SPAWN: ::c_int = 159;
pub const _SC_SPORADIC_SERVER: ::c_int = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 161;
pub const _SC_TIMEOUTS: ::c_int = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 165;
pub const _SC_2_PBS: ::c_int = 168;
pub const _SC_2_PBS_ACCOUNTING: ::c_int = 169;
pub const _SC_2_PBS_LOCATE: ::c_int = 170;
pub const _SC_2_PBS_MESSAGE: ::c_int = 171;
pub const _SC_2_PBS_TRACK: ::c_int = 172;
pub const _SC_SYMLOOP_MAX: ::c_int = 173;
pub const _SC_STREAMS: ::c_int = 174;
pub const _SC_2_PBS_CHECKPOINT: ::c_int = 175;
pub const _SC_V6_ILP32_OFF32: ::c_int = 176;
pub const _SC_V6_ILP32_OFFBIG: ::c_int = 177;
pub const _SC_V6_LP64_OFF64: ::c_int = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 179;
pub const _SC_HOST_NAME_MAX: ::c_int = 180;
pub const _SC_TRACE: ::c_int = 181;
pub const _SC_TRACE_EVENT_FILTER: ::c_int = 182;
pub const _SC_TRACE_INHERIT: ::c_int = 183;
pub const _SC_TRACE_LOG: ::c_int = 184;
pub const L_ctermid: ::c_int = 20;
pub type off_t = ::c_long;
pub type off64_t = ::c_long;
extern "C" {
    pub fn confstr(__name: ::c_int, __buf: *mut ::c_char, __size: ::size_t) -> ::ssize_t;
    pub fn ctermid(__s: *mut ::c_char) -> *mut ::c_char;
    pub fn endusershell();
    pub fn faccessat(
        __fd: ::c_int,
        __path: *const ::c_char,
        __mode: ::c_int,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn ftruncate64(__fd: ::c_int, __size: ::off64_t) -> ::c_int;
    pub fn gethostid() -> ::c_long;
    pub fn sethostname(__buffer: *const ::c_char, __max_length: ::size_t) -> ::c_int;
    pub fn getlogin_r(__buffer: *mut ::c_char, __size: ::size_t) -> ::c_int;
    pub fn getpass(__prompt: *const ::c_char) -> *mut ::c_char;
    pub fn getusershell() -> *mut ::c_char;
    pub fn pread64(
        __fd: ::c_int,
        __buf: *mut ::c_void,
        __size: ::size_t,
        __offset: ::off_t,
    ) -> ::ssize_t;
    pub fn pwrite64(
        __fd: ::c_int,
        __buf: *const ::c_void,
        __size: ::size_t,
        __offset: ::off_t,
    ) -> ::ssize_t;
    pub fn setpgrp() -> ::pid_t;
    pub fn setusershell();
    pub fn swab(__from: *const ::c_void, __to: *mut ::c_void, __size: ::ssize_t);
    pub fn sync();
    pub fn truncate64(__path: *const ::c_char, __size: ::off64_t) -> ::c_int;
}
pub type useconds_t = u64;
extern "C" {
    pub fn getpagesize() -> ::c_int;
    pub fn get_current_dir_name() -> *mut ::c_char;
    pub fn daemon(__nochdir: ::c_int, __noclose: ::c_int) -> ::c_int;
    pub fn gettid() -> ::pid_t;
    pub fn getentropy(__buffer: *mut ::c_void, __size: ::size_t) -> ::c_int;
    pub fn getdomainname(__name: *mut ::c_char, __len: ::size_t) -> ::c_int;
    pub fn setdomainname(__name: *const ::c_char, __len: ::size_t) -> ::c_int;
    pub fn dup3(__fd: ::c_int, __newfd: ::c_int, __flags: ::c_int) -> ::c_int;
    pub fn vhangup() -> ::c_int;
    pub fn getdtablesize() -> ::c_int;
    pub fn syncfs(__fd: ::c_int) -> ::c_int;
}
s! {
    pub struct shm_info {
        pub used_ids: ::c_int,
        pub shm_tot: ::c_ulong,
        pub shm_rss: ::c_ulong,
        pub shm_swp: ::c_ulong,
        pub swap_attempts: ::c_ulong,
        pub swap_successes: ::c_ulong,
    }
}

// abi-bits/signal.h
pub const TIME_UTC: ::c_int = 1;
pub const POLL_IN: ::c_int = 1;
pub const POLL_OUT: ::c_int = 2;
pub const POLL_MSG: ::c_int = 3;
pub const POLL_ERR: ::c_int = 4;
pub const POLL_PRI: ::c_int = 5;
pub const POLL_HUP: ::c_int = 6;
pub const SA_NOCLDSTOP: ::c_ulong = 1;
pub const SA_NOCLDWAIT: ::c_ulong = 2;
pub const SA_SIGINFO: ::c_ulong = 4;
pub const SA_ONSTACK: ::c_ulong = 0x08000000;
pub const SA_RESTART: ::c_ulong = 0x10000000;
pub const SA_NODEFER: ::c_ulong = 0x40000000;
pub const SA_RESETHAND: ::c_ulong = 0x80000000;
pub const SA_RESTORER: ::c_int = 0x04000000;
pub const SIGPROF: ::c_int = 27;
pub const SIGIO: ::c_int = 29;
pub const SIGPWR: ::c_int = 30;
pub const SIG_BLOCK: ::c_int = 0;
pub const SIG_UNBLOCK: ::c_int = 1;
pub const SIG_SETMASK: ::c_int = 2;
pub const SIGBUS: ::c_int = 7;
pub const SIGUSR1: ::c_int = 10;
pub const SIGUSR2: ::c_int = 12;
pub const SIGSTKFLT: ::c_int = 16;
pub const SIGCHLD: ::c_int = 17;
pub const SIGCONT: ::c_int = 18;
pub const SIGSTOP: ::c_int = 19;
pub const SIGTSTP: ::c_int = 20;
pub const SIGTTIN: ::c_int = 21;
pub const SIGTTOU: ::c_int = 22;
pub const SIGURG: ::c_int = 23;
pub const SIGXCPU: ::c_int = 24;
pub const SIGXFSZ: ::c_int = 25;
pub const SIGVTALRM: ::c_int = 26;
pub const SIGWINCH: ::c_int = 28;
pub const SIGPOLL: ::c_int = 29;
pub const SIGSYS: ::c_int = 31;
pub const SIGUNUSED: ::c_int = SIGSYS;
pub const SIGCANCEL: ::c_int = 32;
pub const MINSIGSTKSZ: ::c_int = 2048;
pub const SIGSTKSZ: ::c_int = 8192;
pub const SIGEV_THREAD_ID: ::c_int = 4;
pub const SEGV_MAPERR: ::c_int = 1;
pub const SEGV_ACCERR: ::c_int = 2;
pub const ILL_ILLOPC: ::c_int = 1;
pub const ILL_ILLOPN: ::c_int = 2;
pub const ILL_ILLADR: ::c_int = 3;
pub const ILL_ILLTRP: ::c_int = 4;
pub const ILL_PRVOPC: ::c_int = 5;
pub const ILL_PRVREG: ::c_int = 6;
pub const ILL_COPROC: ::c_int = 7;
pub const ILL_BADSTK: ::c_int = 8;
pub const ILL_BADIADDR: ::c_int = 9;
pub const NSIG: ::c_int = 65;
pub const SI_ASYNCNL: ::c_int = 60;
pub const SI_TKILL: ::c_int = 6;
pub const SI_SIGIO: ::c_int = 5;
pub const SI_ASYNCIO: ::c_int = 4;
pub const SI_MESGQ: ::c_int = 3;
pub const SI_TIMER: ::c_int = 2;
pub const SI_QUEUE: ::c_int = 1;
pub const SI_USER: ::c_int = 0;
pub const SI_KERNEL: ::c_int = 128;
pub const REG_R8: ::c_int = 0;
pub const REG_R9: ::c_int = 1;
pub const REG_R10: ::c_int = 2;
pub const REG_R11: ::c_int = 3;
pub const REG_R12: ::c_int = 4;
pub const REG_R13: ::c_int = 5;
pub const REG_R14: ::c_int = 6;
pub const REG_R15: ::c_int = 7;
pub const REG_RDI: ::c_int = 8;
pub const REG_RSI: ::c_int = 9;
pub const REG_RBP: ::c_int = 10;
pub const REG_RBX: ::c_int = 11;
pub const REG_RDX: ::c_int = 12;
pub const REG_RAX: ::c_int = 13;
pub const REG_RCX: ::c_int = 14;
pub const REG_RSP: ::c_int = 15;
pub const REG_RIP: ::c_int = 16;
pub const REG_EFL: ::c_int = 17;
pub const REG_CSGSFS: ::c_int = 18;
pub const REG_ERR: ::c_int = 19;
pub const REG_TRAPNO: ::c_int = 20;
pub const REG_OLDMASK: ::c_int = 21;
pub const REG_CR2: ::c_int = 22;
pub const NGREG: ::c_int = 23;
pub const CPU_SETSIZE: ::c_int = 1024;
pub const __MLIBC_THREAD_CREATE_JOINABLE: ::c_int = 0;
pub const __MLIBC_THREAD_CREATE_DETACHED: ::c_int = 1;
pub const __MLIBC_THREAD_MUTEX_DEFAULT: ::c_int = 0;
pub const __MLIBC_THREAD_MUTEX_NORMAL: ::c_int = 0;
pub const __MLIBC_THREAD_MUTEX_ERRORCHECK: ::c_int = 1;
pub const __MLIBC_THREAD_MUTEX_RECURSIVE: ::c_int = 2;
pub const __MLIBC_THREAD_PROCESS_PRIVATE: ::c_int = 0;
pub const __MLIBC_THREAD_PROCESS_SHARED: ::c_int = 1;
pub const __MLIBC_THREAD_MUTEX_STALLED: ::c_int = 0;
pub const __MLIBC_THREAD_MUTEX_ROBUST: ::c_int = 1;
pub const __MLIBC_THREAD_PRIO_NONE: ::c_int = 0;
pub const __MLIBC_THREAD_PRIO_INHERIT: ::c_int = 1;
pub const __MLIBC_THREAD_PRIO_PROTECT: ::c_int = 2;
s! {
    pub struct timespec {
        pub tv_sec: ::time_t,
        pub tv_nsec: ::c_long,
    }
}
pub type clock_t = ::c_long;
extern "C" {
    pub fn clock() -> ::clock_t;
    pub fn timespec_get(__ptr: *mut ::timespec, __base: ::c_int) -> ::c_int;
    pub fn asctime(__ptr: *const ::tm) -> *mut ::c_char;
    pub fn ctime(__timer: *const ::time_t) -> *mut ::c_char;
    pub fn strftime(
        __dest: *mut ::c_char,
        __max_size: ::size_t,
        __format: *const ::c_char,
        __ptr: *const ::tm,
    ) -> ::size_t;
    pub fn tzset();
}
extern "C" {
    pub fn timer_getoverrun(__timerid: ::timer_t) -> ::c_int;
    pub fn futimes(__fd: ::c_int, __tv: *const ::timeval) -> ::c_int;
    pub fn lutimes(__filename: *const ::c_char, __tv: *const ::timeval) -> ::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clockid: ::clockid_t,
        __flags: ::c_int,
        __req: *const ::timespec,
        __rem: *mut ::timespec,
    ) -> ::c_int;
    pub fn asctime_r(__tm: *const ::tm, __buf: *mut ::c_char) -> *mut ::c_char;
    pub fn ctime_r(__timer: *const ::time_t, __buf: *mut ::c_char) -> *mut ::c_char;
}
extern "C" {
    pub fn strptime(
        __buf: *const ::c_char,
        __format: *const ::c_char,
        __tm: *mut ::tm,
    ) -> *mut ::c_char;
    pub fn timelocal(__tm: *mut ::tm) -> ::time_t;
}
s! {
    pub struct itimerspec {
        pub it_interval: ::timespec,
        pub it_value: ::timespec,
    }
}
s_no_extra_traits! {
#[repr(C)]
    pub union sigval {
        pub sival_int: ::c_int,
        pub sival_ptr: *mut ::c_void,
    }
}
s! {
    pub struct siginfo_t {
        pub si_signo: ::c_int,
        pub si_errno: ::c_int,
        pub si_code: ::c_int,
        pub __si_fields: [::c_char; 124],
    }
}
pub type __sighandler = ::Option<unsafe extern "C" fn(::c_int) -> ::c_void>;
s! {
    pub struct sigset_t {
        pub sig: [::c_ulong; 16],
    }
}
s! {
    pub struct __stack {
        pub ss_sp: *mut ::c_void,
        pub ss_flags: ::c_int,
        pub ss_size: ::size_t,
    }
}
pub type stack_t = ::__stack;
pub type __cpu_mask = ::c_ulong;
s! {
    pub struct cpu_set_t {
        pub __bits: [::__cpu_mask; 16],
    }
}
s! {
    pub struct __mlibc_thread_data {
    }
    pub struct __mlibc_threadattr {
        pub __mlibc_guardsize: ::size_t,
        pub __mlibc_stacksize: ::size_t,
        pub __mlibc_stackaddr: *mut ::c_void,
        pub __mlibc_detachstate: ::c_int,
        pub __mlibc_scope: ::c_int,
        pub __mlibc_inheritsched: ::c_int,
        pub __mlibc_schedparam: ::sched_param,
        pub __mlibc_schedpolicy: ::c_int,
        pub __mlibc_cpuset: *mut ::cpu_set_t,
        pub __mlibc_cpusetsize: ::size_t,
        pub __mlibc_sigmask: ::sigset_t,
        pub __mlibc_sigmaskset: ::c_int,
    }
    pub struct __mlibc_mutex {
        #[doc(hidden)]
        size: [u8; 16],
    }
    pub struct __mlibc_mutexattr {
        pub __mlibc_type: ::c_int,
        pub __mlibc_robust: ::c_int,
        pub __mlibc_protocol: ::c_int,
        pub __mlibc_pshared: ::c_int,
        pub __mlibc_prioceiling: ::c_int,
    }
    pub struct __mlibc_cond {
        #[doc(hidden)]
        size: [u8; 12],
    }
    pub struct __mlibc_condattr {
        pub __mlibc_pshared: ::c_int,
        pub __mlibc_clock: ::clockid_t,
    }
    pub struct sigaction {
        pub sa_sigaction: sighandler_t,
        pub sa_flags: ::c_ulong,
        pub sa_restorer: ::Option<unsafe extern "C" fn() -> ::c_void>,
        pub sa_mask: ::sigset_t,
    }
    pub struct _fpreg {
        pub significand: [::c_ushort; 4],
        pub exponent: ::c_ushort,
    }
    pub struct _fpxreg {
        pub significand: [::c_ushort; 4],
        pub exponent: ::c_ushort,
        pub padding: [::c_ushort; 3],
    }
    pub struct _xmmreg {
        pub element: [u32; 4],
    }
    pub struct _fpstate {
        pub cwd: u16,
        pub swd: u16,
        pub ftw: u16,
        pub fop: u16,
        pub rip: u64,
        pub rdp: u64,
        pub mxcsr: u32,
        pub mxcr_mask: u32,
        pub _st: [::_fpxreg; 8],
        pub _xmm: [::_xmmreg; 16],
        pub padding: [u32; 24],
    }
    pub struct sigcontext {
        pub r8: ::c_ulong,
        pub r9: ::c_ulong,
        pub r10: ::c_ulong,
        pub r11: ::c_ulong,
        pub r12: ::c_ulong,
        pub r13: ::c_ulong,
        pub r14: ::c_ulong,
        pub r15: ::c_ulong,
        pub rdi: ::c_ulong,
        pub rsi: ::c_ulong,
        pub rbp: ::c_ulong,
        pub rbx: ::c_ulong,
        pub rdx: ::c_ulong,
        pub rax: ::c_ulong,
        pub rcx: ::c_ulong,
        pub rsp: ::c_ulong,
        pub rip: ::c_ulong,
        pub eflags: ::c_ulong,
        pub cs: ::c_ushort,
        pub gs: ::c_ushort,
        pub fs: ::c_ushort,
        pub __pad0: ::c_ushort,
        pub err: ::c_ulong,
        pub trapno: ::c_ulong,
        pub oldmask: ::c_ulong,
        pub cr2: ::c_ulong,
        pub fpstate: *mut ::_fpstate,
        pub __reserved1: [::c_ulong; 8],
    }
    pub struct mcontext_t {
        pub gregs: [::c_ulong; 23],
        pub fpregs: *mut ::_fpstate,
        pub __reserved1: [::c_ulong; 8],
    }
}
s! {
    pub struct __ucontext {
        pub uc_flags: ::c_ulong,
        pub uc_link: *mut ::__ucontext,
        pub uc_stack: ::stack_t,
        pub uc_mcontext: ::mcontext_t,
        pub uc_sigmask: ::sigset_t,
    }
}
pub type ucontext_t = ::__ucontext;

// abi-bits/socket.h

// abi-bits/socklen_t.h

// abi-bits/stat.h
s! {
    pub struct stat {
        pub st_dev: ::dev_t,
        pub st_ino: ::ino_t,
        pub st_nlink: ::nlink_t,
        pub st_mode: ::mode_t,
        pub st_uid: ::uid_t,
        pub st_gid: ::gid_t,
        pub __pad0: ::c_uint,
        pub st_rdev: ::dev_t,
        pub st_size: ::off_t,
        pub st_blksize: ::blksize_t,
        pub st_blocks: ::blkcnt_t,
        pub st_atime: ::time_t,
        pub st_atime_nsec: i64,
        pub st_mtime: ::time_t,
        pub st_mtime_nsec: i64,
        pub st_ctime: ::time_t,
        pub st_ctime_nsec: i64,
        pub __unused: [::c_long; 3],
    }
}

// abi-bits/statfs.h
s! {
    pub struct __mlibc_fsid {
        pub __val: [::c_int; 2],
    }
}
pub type fsid_t = ::__mlibc_fsid;
s! {
    pub struct statfs {
        pub f_type: ::c_ulong,
        pub f_bsize: ::c_ulong,
        pub f_blocks: ::fsblkcnt_t,
        pub f_bfree: ::fsblkcnt_t,
        pub f_bavail: ::fsblkcnt_t,
        pub f_files: ::fsfilcnt_t,
        pub f_ffree: ::fsfilcnt_t,
        pub f_fsid: ::fsid_t,
        pub f_namelen: ::c_ulong,
        pub f_frsize: ::c_ulong,
        pub f_flags: ::c_ulong,
        pub __f_spare: [::c_ulong; 4],
    }
}

// abi-bits/statvfs.h
pub const ST_RDONLY: ::c_int = 1;
pub const ST_NOSUID: ::c_int = 2;
pub const ST_MANDLOCK: ::c_int = 64;
s! {
    pub struct statvfs {
        pub f_bsize: ::c_ulong,
        pub f_frsize: ::c_ulong,
        pub f_blocks: ::fsblkcnt_t,
        pub f_bfree: ::fsblkcnt_t,
        pub f_bavail: ::fsblkcnt_t,
        pub f_files: ::fsfilcnt_t,
        pub f_ffree: ::fsfilcnt_t,
        pub f_favail: ::fsfilcnt_t,
        pub f_fsid: ::c_ulong,
        pub f_flag: ::c_ulong,
        pub f_namemax: ::c_ulong,
    }
}

// abi-bits/statx.h
pub const STATX_TYPE: ::c_int = 0x1;
pub const STATX_MODE: ::c_int = 0x2;
pub const STATX_NLINK: ::c_int = 0x4;
pub const STATX_UID: ::c_int = 0x8;
pub const STATX_GID: ::c_int = 0x10;
pub const STATX_ATIME: ::c_int = 0x20;
pub const STATX_MTIME: ::c_int = 0x40;
pub const STATX_CTIME: ::c_int = 0x80;
pub const STATX_INO: ::c_int = 0x100;
pub const STATX_SIZE: ::c_int = 0x200;
pub const STATX_BLOCKS: ::c_int = 0x400;
pub const STATX_BASIC_STATS: ::c_int = 0x7ff;
pub const STATX_BTIME: ::c_int = 0x800;
pub const STATX_MNT_ID: ::c_int = 0x1000;
pub const STATX_DIOALIGN: ::c_int = 0x2000;
pub const STATX_ALL: ::c_int = 0xfff;
pub const STATX_ATTR_COMPRESSED: ::c_int = 0x4;
pub const STATX_ATTR_IMMUTABLE: ::c_int = 0x10;
pub const STATX_ATTR_APPEND: ::c_int = 0x20;
pub const STATX_ATTR_NODUMP: ::c_int = 0x40;
pub const STATX_ATTR_ENCRYPTED: ::c_int = 0x800;
pub const STATX_ATTR_AUTOMOUNT: ::c_int = 0x1000;
pub const STATX_ATTR_MOUNT_ROOT: ::c_int = 0x2000;
pub const STATX_ATTR_VERITY: ::c_int = 0x100000;
pub const STATX_ATTR_DAX: ::c_int = 0x200000;
s! {
    pub struct statx_timestamp {
        pub tv_sec: i64,
        pub tv_nsec: u32,
        pub __padding: u32,
    }
    pub struct statx {
        pub stx_mask: u32,
        pub stx_blksize: u32,
        pub stx_attributes: u64,
        pub stx_nlink: u32,
        pub stx_uid: u32,
        pub stx_gid: u32,
        pub stx_mode: u16,
        pub __padding: u16,
        pub stx_ino: u64,
        pub stx_size: u64,
        pub stx_blocks: u64,
        pub stx_attributes_mask: u64,
        pub stx_atime: ::statx_timestamp,
        pub stx_btime: ::statx_timestamp,
        pub stx_ctime: ::statx_timestamp,
        pub stx_mtime: ::statx_timestamp,
        pub stx_rdev_major: u32,
        pub stx_rdev_minor: u32,
        pub stx_dev_major: u32,
        pub stx_dev_minor: u32,
        pub stx_mnt_id: u64,
        pub stx_dio_mem_align: u32,
        pub stx_dio_offset_align: u32,
        pub __padding1: [u64; 12],
    }
}

// abi-bits/suseconds_t.h

// abi-bits/termios.h
pub const NCCS: usize = 32;
pub const VEOF: usize = 4;
pub const VTIME: ::c_int = 5;
pub const VMIN: ::c_int = 6;
pub const VSWTC: ::c_int = 7;
pub const VSTART: ::c_int = 8;
pub const VSTOP: ::c_int = 9;
pub const VSUSP: ::c_int = 10;
pub const VEOL: ::c_int = 11;
pub const VREPRINT: ::c_int = 12;
pub const VDISCARD: ::c_int = 13;
pub const VWERASE: ::c_int = 14;
pub const VEOL2: ::c_int = 16;
pub const IUCLC: ::c_uint = 0o001000;
pub const IXON: ::c_uint = 0o002000;
pub const IXOFF: ::c_uint = 0o010000;
pub const IUTF8: ::tcflag_t = 0o040000;
pub const OLCUC: ::tcflag_t = 0o000002;
pub const ONLCR: ::tcflag_t = 0o000004;
pub const NLDLY: ::tcflag_t = 0o000400;
pub const CRDLY: ::tcflag_t = 0o003000;
pub const CR1: ::tcflag_t = 0o001000;
pub const CR2: ::tcflag_t = 0o002000;
pub const CR3: ::tcflag_t = 0o003000;
pub const TABDLY: ::tcflag_t = 0o014000;
pub const TAB1: ::tcflag_t = 0o004000;
pub const TAB2: ::tcflag_t = 0o010000;
pub const TAB3: ::tcflag_t = 0o014000;
pub const BSDLY: ::tcflag_t = 0o020000;
pub const BS1: ::tcflag_t = 0o020000;
pub const FFDLY: ::tcflag_t = 0o100000;
pub const FF1: ::tcflag_t = 0o100000;
pub const VTDLY: ::tcflag_t = 0o040000;
pub const VT1: ::tcflag_t = 0o040000;
pub const CSIZE: ::tcflag_t = 0o000060;
pub const CS6: ::tcflag_t = 0o000020;
pub const CS7: ::tcflag_t = 0o000040;
pub const CS8: ::tcflag_t = 0o000060;
pub const CSTOPB: ::tcflag_t = 0o000100;
pub const CREAD: ::tcflag_t = 0o000200;
pub const PARENB: ::tcflag_t = 0o000400;
pub const PARODD: ::tcflag_t = 0o001000;
pub const HUPCL: ::tcflag_t = 0o002000;
pub const CLOCAL: ::tcflag_t = 0o004000;
pub const ISIG: ::tcflag_t = 0o000001;
pub const ICANON: ::tcflag_t = 0o000002;
pub const ECHOE: ::tcflag_t = 0o000020;
pub const ECHOK: ::tcflag_t = 0o000040;
pub const ECHONL: ::tcflag_t = 0o000100;
pub const NOFLSH: ::tcflag_t = 0o000200;
pub const TOSTOP: ::tcflag_t = 0o000400;
pub const IEXTEN: ::tcflag_t = 0o100000;
pub const EXTA: ::c_int = 0o000016;
pub const EXTB: ::c_int = 0o000017;
pub const CBAUD: ::c_int = 0o010017;
pub const CBAUDEX: ::c_int = 0o010000;
pub const CIBAUD: ::c_int = 0o02003600000;
pub const CMSPAR: ::tcflag_t = 0o10000000000;
pub const XCASE: ::c_int = 0o000004;
pub const ECHOCTL: ::tcflag_t = 0o001000;
pub const ECHOPRT: ::tcflag_t = 0o002000;
pub const ECHOKE: ::tcflag_t = 0o004000;
pub const FLUSHO: ::tcflag_t = 0o010000;
pub const PENDIN: ::tcflag_t = 0o040000;
pub const EXTPROC: ::tcflag_t = 0o200000;
pub const XTABS: ::tcflag_t = 0o014000;
pub const NCC: ::c_int = 8;
s! {
    pub struct termios {
        pub c_iflag: ::tcflag_t,
        pub c_oflag: ::tcflag_t,
        pub c_cflag: ::tcflag_t,
        pub c_lflag: ::tcflag_t,
        pub c_line: ::cc_t,
        pub c_cc: [::cc_t; 32],
        pub ibaud: ::speed_t,
        pub obaud: ::speed_t,
    }
    pub struct termio {
        pub c_iflag: ::c_ushort,
        pub c_oflag: ::c_ushort,
        pub c_cflag: ::c_ushort,
        pub c_lflag: ::c_ushort,
        pub c_line: ::c_uchar,
        pub c_cc: [::c_uchar; 8],
    }
}

// abi-bits/time.h
pub const ITIMER_REAL: ::c_int = 0;
pub const ITIMER_VIRTUAL: ::c_int = 1;
pub const ITIMER_PROF: ::c_int = 2;
s! {
    pub struct itimerval {
        pub it_interval: ::timeval,
        pub it_value: ::timeval,
    }
}

// abi-bits/uid_t.h

// abi-bits/utsname.h

// abi-bits/vm-flags.h
pub const MAP_ANON: ::c_int = 0x08;
pub const MAP_ANONYMOUS: ::c_int = 0x08;
pub const MAP_NORESERVE: ::c_int = 0x10;
pub const MAP_FIXED_NOREPLACE: ::c_int = 0x20;
pub const MCL_CURRENT: ::c_int = 0x01;
pub const MCL_FUTURE: ::c_int = 0x02;
pub const POSIX_MADV_NORMAL: ::c_int = 1;
pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
pub const POSIX_MADV_RANDOM: ::c_int = 3;
pub const POSIX_MADV_DONTNEED: ::c_int = 4;
pub const POSIX_MADV_WILLNEED: ::c_int = 5;
pub const MREMAP_MAYMOVE: ::c_int = 1;
pub const MREMAP_FIXED: ::c_int = 2;
pub const MFD_CLOEXEC: ::c_uint = 1;
pub const MFD_ALLOW_SEALING: ::c_uint = 2;

// alloca.h

// arpa/inet.h
pub const IN_CLASSA_NET: ::c_int = 0xff000000;
pub const IN_CLASSA_NSHIFT: ::c_int = 24;
pub const IN_CLASSA_MAX: ::c_int = 128;
pub const IN_CLASSB_NET: ::c_int = 0xffff0000;
pub const IN_CLASSB_NSHIFT: ::c_int = 16;
pub const IN_CLASSB_MAX: ::c_int = 65536;
pub const IN_CLASSC_NET: ::c_int = 0xffffff00;
pub const IN_CLASSC_NSHIFT: ::c_int = 8;
pub const IN_LOOPBACKNET: ::c_int = 127;
s! {
    pub struct linger {
        pub l_onoff: ::c_int,
        pub l_linger: ::c_int,
    }
    pub struct ucred {
        pub pid: ::pid_t,
        pub uid: ::uid_t,
        pub gid: ::gid_t,
    }
}
extern "C" {
    pub fn accept4(
        __sockfd: ::c_int,
        __addr: *mut ::sockaddr,
        __addrlen: *mut ::socklen_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn recvfrom(
        __sockfd: ::c_int,
        __buf: *mut ::c_void,
        __size: ::size_t,
        __flags: ::c_int,
        __src_addr: *mut ::sockaddr,
        __addrlen: *mut ::socklen_t,
    ) -> ::ssize_t;
    pub fn recvmmsg(
        __sockfd: ::c_int,
        __msgvec: *mut ::mmsghdr,
        __vlen: ::c_uint,
        __flags: ::c_int,
        __timeout: *mut ::timespec,
    ) -> ::c_int;
    pub fn sendmmsg(
        __sockfd: ::c_int,
        __msgvec: *mut ::mmsghdr,
        __vlen: ::c_uint,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn sockatmark(__sockfd: ::c_int) -> ::c_int;
}
extern "C" {
    pub fn htonl(__x: u32) -> u32;
    pub fn htons(__x: u16) -> u16;
    pub fn ntohl(__x: u32) -> u32;
    pub fn ntohs(__x: u16) -> u16;
    pub fn inet_addr(__cp: *const ::c_char) -> ::in_addr_t;
    pub fn inet_network(__cp: *const ::c_char) -> ::in_addr_t;
    pub fn inet_ntoa(__in: ::in_addr) -> *mut ::c_char;
    pub fn inet_aton(__cp: *const ::c_char, __dest: *mut ::in_addr) -> ::c_int;
    pub fn inet_ntop(
        __af: ::c_int,
        __src: *const ::c_void,
        __dst: *mut ::c_char,
        __size: ::socklen_t,
    ) -> *const ::c_char;
    pub fn inet_pton(__af: ::c_int, __src: *const ::c_char, __dst: *mut ::c_void) -> ::c_int;
    pub fn inet_makeaddr(__net: ::in_addr_t, __host: ::in_addr_t) -> ::in_addr;
    pub fn inet_netof(__in: ::in_addr) -> ::in_addr_t;
}

// arpa/nameser_compat.h

// assert.h

// bits/ansi/fenv.h
pub const FE_DENORMAL: ::c_int = 2;
pub const FE_DIVBYZERO: ::c_int = 4;
pub const FE_INEXACT: ::c_int = 32;
pub const FE_INVALID: ::c_int = 1;
pub const FE_OVERFLOW: ::c_int = 8;
pub const FE_UNDERFLOW: ::c_int = 16;
pub const FE_TONEAREST: ::c_int = 0;
pub const FE_DOWNWARD: ::c_int = 0x400;
pub const FE_UPWARD: ::c_int = 0x800;
pub const FE_TOWARDZERO: ::c_int = 0xC00;

// bits/ansi/time_t.h

// bits/ansi/timespec.h

// bits/bsd/bsd_unistd.h

// bits/cpu_set.h

// bits/ether_addr.h
s! {
    #[repr(packed)]
    pub struct ether_addr {
        pub ether_addr_octet: [u8; 6],
    }
}

// bits/file.h

// bits/glibc/glibc_icmp6.h
pub const ND_OPT_SOURCE_LINKADDR: ::c_int = 1;
pub const ND_OPT_TARGET_LINKADDR: ::c_int = 2;
pub const ND_OPT_PREFIX_INFORMATION: ::c_int = 3;
pub const ND_OPT_REDIRECTED_HEADER: ::c_int = 4;
pub const ND_OPT_MTU: ::c_int = 5;
pub const ND_OPT_RTR_ADV_INTERVAL: ::c_int = 7;
pub const ND_OPT_HOME_AGENT_INFO: ::c_int = 8;

// bits/glibc/glibc_malloc.h
extern "C" {
    pub fn malloc_usable_size(__ptr: *mut ::c_void) -> ::size_t;
}

// bits/inline-definition.h

// bits/linux/cpu_set.h
pub const CHAR_BIT: ::c_int = 8;
pub const MB_LEN_MAX: ::c_int = 4;
pub const LONG_BIT: ::c_int = 64;
pub const NAME_MAX: ::c_int = 255;
pub const LINE_MAX: ::c_int = 4096;
pub const CHARCLASS_NAME_MAX: ::c_int = 14;
pub const RE_DUP_MAX: ::c_int = 255;
pub const NGROUPS_MAX: ::c_int = 8;
pub const NL_ARGMAX: ::c_int = 9;
pub const _POSIX_ARG_MAX: ::c_int = 4096;
pub const _POSIX_OPEN_MAX: ::c_int = 16;
pub const _POSIX_HOST_NAME_MAX: ::c_int = 255;
pub const _POSIX_NAME_MAX: ::c_int = 14;
pub const _POSIX_TZNAME_MAX: ::c_int = 6;
pub const _XOPEN_NAME_MAX: ::c_int = 255;
pub const PTHREAD_STACK_MIN: usize = 16384;
pub const PTHREAD_KEYS_MAX: ::c_int = 1024;
pub type wchar_t = ::c_int;
extern "C" {
    pub fn rand() -> ::c_int;
    pub fn rand_r(__seed: *mut ::c_uint) -> ::c_int;
    pub fn srand(__seed: ::c_uint);
    pub fn aligned_alloc(__alignment: ::size_t, __size: ::size_t) -> *mut ::c_void;
    pub fn at_quick_exit(__func: ::Option<unsafe extern "C" fn() -> ::c_void>) -> ::c_int;
    pub fn _Exit(__status: ::c_int);
    pub fn quick_exit(__status: ::c_int);
    pub fn mktemp(__pattern: *mut ::c_char) -> *mut ::c_char;
    pub fn qsort_r(
        __base: *mut ::c_void,
        __nmemb: ::size_t,
        __size: ::size_t,
        __compar: ::Option<
            unsafe extern "C" fn(*const ::c_void, *const ::c_void, *mut ::c_void) -> ::c_int,
        >,
        __arg: *mut ::c_void,
    );
    pub fn abs(__number: ::c_int) -> ::c_int;
    pub fn labs(__number: ::c_long) -> ::c_long;
    pub fn llabs(__number: ::c_longlong) -> ::c_longlong;
    pub fn mblen(__mbs: *const ::c_char, __limit: ::size_t) -> ::c_int;
    pub fn mbtowc(__wc: *mut ::wchar_t, __mb_chr: *const ::c_char, __max_size: ::size_t)
        -> ::c_int;
    pub fn wctomb(__mb_chr: *mut ::c_char, __wc: ::wchar_t) -> ::c_int;
    pub fn mbstowcs(
        __wc_string: *mut ::wchar_t,
        __mb_string: *const ::c_char,
        __max_size: ::size_t,
    ) -> ::size_t;
}
pub type comparison_fn_t =
    ::Option<unsafe extern "C" fn(*const ::c_void, *const ::c_void) -> ::c_int>;
extern "C" {
    pub fn random() -> ::c_long;
    pub fn drand48() -> ::c_double;
    pub fn erand48(__s: *mut ::c_ushort) -> ::c_double;
    pub fn seed48(__s: *mut ::c_ushort) -> *mut ::c_ushort;
    pub fn srand48(__seed: ::c_long);
    pub fn jrand48(__s: *mut ::c_ushort) -> ::c_long;
    pub fn initstate(__seed: ::c_uint, __state: *mut ::c_char, __size: ::size_t) -> *mut ::c_char;
    pub fn setstate(__state: *mut ::c_char) -> *mut ::c_char;
    pub fn srandom(__seed: ::c_uint);
    pub fn mkstemps(__pattern: *mut ::c_char, __suffixlen: ::c_int) -> ::c_int;
    pub fn mkostemp(__pattern: *mut ::c_char, __flags: ::c_int) -> ::c_int;
    pub fn mkostemps(__pattern: *mut ::c_char, __suffixlen: ::c_int, __flags: ::c_int) -> ::c_int;
    pub fn strtod_l(
        __nptr: *const ::c_char,
        __endptr: *mut *mut ::c_char,
        __loc: ::locale_t,
    ) -> ::c_double;
    pub fn strtof_l(
        __string: *const ::c_char,
        __end: *mut *mut ::c_char,
        __loc: ::locale_t,
    ) -> ::c_float;
    pub fn getloadavg(__loadavg: *mut ::c_double, __count: ::c_int) -> ::c_int;
    pub fn getsubopt(
        __optionp: *mut *mut ::c_char,
        __tokens: *mut *mut ::c_char,
        __valuep: *mut *mut ::c_char,
    ) -> ::c_int;
    pub fn secure_getenv(__name: *const ::c_char) -> *mut ::c_char;
    pub fn canonicalize_file_name(__name: *const ::c_char) -> *mut ::c_char;
    pub fn reallocarray(__ptr: *mut ::c_void, __count: ::size_t, __size: ::size_t)
        -> *mut ::c_void;
}

// bits/linux/linux_sched.h
extern "C" {
    pub fn sched_getscheduler(__pid: ::pid_t) -> ::c_int;
    pub fn sched_setaffinity(
        __pid: ::pid_t,
        __cpusetsize: ::size_t,
        __mask: *const ::cpu_set_t,
    ) -> ::c_int;
    pub fn sched_getaffinity(
        __pid: ::pid_t,
        __cpusetsize: ::size_t,
        __mask: *mut ::cpu_set_t,
    ) -> ::c_int;
    pub fn unshare(flags: ::c_int) -> ::c_int;
    pub fn clone(
        arg0: ::Option<unsafe extern "C" fn(*mut ::c_void) -> ::c_int>,
        arg1: *mut ::c_void,
        arg2: ::c_int,
        arg3: *mut ::c_void,
        ...
    ) -> ::c_int;
    pub fn sched_getcpu() -> ::c_int;
    pub fn setns(fd: ::c_int, nstype: ::c_int) -> ::c_int;
}

// bits/linux/linux_stat.h
extern "C" {
    pub fn statx(
        __dirfd: ::c_int,
        __pathname: *const ::c_char,
        __flags: ::c_int,
        __mask: ::c_uint,
        __statxbuf: *mut ::statx,
    ) -> ::c_int;
}

// bits/linux/linux_unistd.h

// bits/machine.h

// bits/mbstate.h
s! {
    pub struct __mlibc_mbstate {
        pub __progress: ::c_short,
        pub __shift: ::c_short,
        pub __cpoint: ::c_uint,
    }
}
pub type mbstate_t = ::__mlibc_mbstate;

// bits/nl_item.h
pub const ABDAY_1: ::c_int = 0x60000;
pub const ABDAY_2: ::c_int = 0x60001;
pub const ABDAY_3: ::c_int = 0x60002;
pub const ABDAY_4: ::c_int = 0x60003;
pub const ABDAY_5: ::c_int = 0x60004;
pub const ABDAY_6: ::c_int = 0x60005;
pub const ABDAY_7: ::c_int = 0x60006;
pub const DAY_1: ::c_int = 0x60007;
pub const DAY_2: ::c_int = 0x60008;
pub const DAY_3: ::c_int = 0x60009;
pub const DAY_4: ::c_int = 0x6000A;
pub const DAY_5: ::c_int = 0x6000B;
pub const DAY_6: ::c_int = 0x6000C;
pub const DAY_7: ::c_int = 0x6000D;
pub const ABMON_1: ::c_int = 0x6000E;
pub const ABMON_2: ::c_int = 0x6000F;
pub const ABMON_3: ::c_int = 0x60010;
pub const ABMON_4: ::c_int = 0x60011;
pub const ABMON_5: ::c_int = 0x60012;
pub const ABMON_6: ::c_int = 0x60013;
pub const ABMON_7: ::c_int = 0x60014;
pub const ABMON_8: ::c_int = 0x60015;
pub const ABMON_9: ::c_int = 0x60016;
pub const ABMON_10: ::c_int = 0x60017;
pub const ABMON_11: ::c_int = 0x60018;
pub const ABMON_12: ::c_int = 0x60019;
pub const MON_1: ::c_int = 0x6001A;
pub const MON_2: ::c_int = 0x6001B;
pub const MON_3: ::c_int = 0x6001C;
pub const MON_4: ::c_int = 0x6001D;
pub const MON_5: ::c_int = 0x6001E;
pub const MON_6: ::c_int = 0x6001F;
pub const MON_7: ::c_int = 0x60020;
pub const MON_8: ::c_int = 0x60021;
pub const MON_9: ::c_int = 0x60022;
pub const MON_10: ::c_int = 0x60023;
pub const MON_11: ::c_int = 0x60024;
pub const MON_12: ::c_int = 0x60025;
pub const AM_STR: ::c_int = 0x60026;
pub const PM_STR: ::c_int = 0x60027;
pub const D_T_FMT: ::c_int = 0x60028;
pub const D_FMT: ::c_int = 0x60029;
pub const T_FMT: ::c_int = 0x6002A;
pub const T_FMT_AMPM: ::c_int = 0x6002B;
pub const ERA: ::c_int = 0x6002C;
pub const ERA_D_FMT: ::c_int = 0x6002D;
pub const ALT_DIGITS: ::c_int = 0x6002E;
pub const ERA_D_T_FMT: ::c_int = 0x6002F;
pub const ERA_T_FMT: ::c_int = 0x60030;
pub const CODESET: ::c_int = 0x30000;
pub const CRNCYSTR: ::c_int = 0x40000;
pub const RADIXCHAR: ::c_int = 0x50000;
pub const DECIMAL_POINT: ::c_int = RADIXCHAR;
pub const THOUSEP: ::c_int = 0x50001;
pub const THOUSANDS_SEP: ::c_int = THOUSEP;
pub const YESEXPR: ::c_int = 0x70000;
pub const NOEXPR: ::c_int = 0x70001;
pub type nl_item = ::c_int;

// bits/off_t.h

// bits/posix/fd_set.h

// bits/posix/id_t.h

// bits/posix/in_addr_t.h

// bits/posix/in_port_t.h

// bits/posix/iovec.h

// bits/posix/locale_t.h

// bits/posix/posix_ctype.h
extern "C" {
    pub fn isalnum_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isalpha_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isblank_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn iscntrl_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isdigit_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isgraph_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn islower_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isprint_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn ispunct_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isspace_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isupper_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isxdigit_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn isascii_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn tolower_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
    pub fn toupper_l(__c: ::c_int, __loc: ::locale_t) -> ::c_int;
}

// bits/posix/posix_locale.h

// bits/posix/posix_signal.h
pub const FPE_INTDIV: ::c_int = 1;
pub const FPE_INTOVF: ::c_int = 2;
pub const FPE_FLTDIV: ::c_int = 3;
pub const FPE_FLTOVF: ::c_int = 4;
pub const FPE_FLTUND: ::c_int = 5;
pub const FPE_FLTRES: ::c_int = 6;
pub const FPE_FLTINV: ::c_int = 7;
pub const FPE_FLTSUB: ::c_int = 8;
pub const TRAP_BRKPT: ::c_int = 1;
pub const TRAP_TRACE: ::c_int = 2;
pub type pthread_t = *mut ::__mlibc_thread_data;
s! {
    pub struct _libc_fpxreg {
        pub significand: [::c_ushort; 4],
        pub exponent: ::c_ushort,
        pub __glibc_reserved1: [::c_ushort; 3],
    }
    pub struct _libc_xmmreg {
        pub element: [u32; 4],
    }
    pub struct _libc_fpstate {
        pub cwd: u16,
        pub swd: i16,
        pub ftw: u16,
        pub fop: u16,
        pub rip: u64,
        pub dp: u64,
        pub mxcsr: u32,
        pub mxcr_mask: u32,
        pub _st: [::_libc_fpxreg; 8],
        pub _xmm: [::_libc_xmmreg; 16],
        pub __glibc_reserved1: [u32; 24],
    }
}
pub type fpregset_t = *mut ::_libc_fpstate;
pub type greg_t = ::c_ulong;
extern "C" {
    pub fn sigsuspend(__sigmask: *const ::sigset_t) -> ::c_int;
    pub fn pthread_sigmask(
        __how: ::c_int,
        __sigmask: *const ::sigset_t,
        __oldmask: *mut ::sigset_t,
    ) -> ::c_int;
    pub fn pthread_kill(__thrd: ::pthread_t, __sig: ::c_int) -> ::c_int;
    pub fn siginterrupt(__sig: ::c_int, __flag: ::c_int) -> ::c_int;
    pub fn sigaltstack(__ss: *const ::stack_t, __oss: *mut ::stack_t) -> ::c_int;
    pub fn sigtimedwait(
        __set: *const ::sigset_t,
        __info: *mut ::siginfo_t,
        __timeout: *const ::timespec,
    ) -> ::c_int;
    pub fn sigwait(__set: *const ::sigset_t, __sig: *mut ::c_int) -> ::c_int;
    pub fn sigwaitinfo(__set: *const ::sigset_t, __info: *mut ::siginfo_t) -> ::c_int;
    pub fn sigisemptyset(__set: *const ::sigset_t) -> ::c_int;
    pub fn sigqueue(__pid: ::pid_t, __sig: ::c_int, __value: ::sigval) -> ::c_int;
}

// bits/posix/posix_stdio.h
extern "C" {
    pub fn popen(__command: *const ::c_char, __type: *const ::c_char) -> *mut ::FILE;
    pub fn fseeko64(__stream: *mut ::FILE, __offset: ::off64_t, __whence: ::c_int) -> ::c_int;
    pub fn ftello64(__stream: *mut ::FILE) -> ::off64_t;
    pub fn dprintf(__fd: ::c_int, __format: *const ::c_char, ...) -> ::c_int;
    pub fn vdprintf(__fd: ::c_int, __format: *const ::c_char, __args: *mut c_char) -> ::c_int;
    pub fn fgetln(__stream: *mut ::FILE, __size: *mut ::size_t) -> *mut ::c_char;
    pub fn tempnam(__dir: *const ::c_char, __pfx: *const ::c_char) -> *mut ::c_char;
}

// bits/posix/posix_stdlib.h

// bits/posix/posix_string.h
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::c_char, __delim: *const ::c_char) -> *mut ::c_char;
    pub fn memccpy(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __c: ::c_int,
        __n: ::size_t,
    ) -> *mut ::c_void;
    pub fn strcoll_l(__s1: *const ::c_char, __s2: *const ::c_char, __locale: ::locale_t)
        -> ::c_int;
    pub fn strerror_l(__errnum: ::c_int, __locale: ::locale_t) -> *mut ::c_char;
    pub fn strlcpy(__d: *mut ::c_char, __s: *const ::c_char, __n: ::size_t) -> ::c_ulong;
    pub fn strlcat(__d: *mut ::c_char, __s: *const ::c_char, __n: ::size_t) -> ::c_ulong;
}

// bits/posix/posix_time.h

// bits/posix/posix_wctype.h
pub type wint_t = ::c_uint;
pub type wctype_t = ::c_ulong;
pub type wctrans_t = ::c_ulong;
extern "C" {
    pub fn iswalnum_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswblank_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswcntrl_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswdigit_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswgraph_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswlower_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswprint_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswpunct_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswspace_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswupper_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswxdigit_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn iswalpha_l(__wc: ::wint_t, __loc: ::locale_t) -> ::c_int;
    pub fn wctype_l(__string: *const ::c_char, __loc: ::locale_t) -> ::wctype_t;
    pub fn iswctype_l(__wc: ::wint_t, __type: ::wctype_t, __loc: ::locale_t) -> ::c_int;
    pub fn towlower_l(__wc: ::wint_t, __loc: ::locale_t) -> ::wint_t;
    pub fn towupper_l(__wc: ::wint_t, __loc: ::locale_t) -> ::wint_t;
    pub fn wctrans_l(__string: *const ::c_char, __loc: ::locale_t) -> ::wctrans_t;
    pub fn towctrans_l(__wc: ::wint_t, __trans: ::wctrans_t, __loc: ::locale_t) -> ::wint_t;
}

// bits/posix/pthread_t.h

// bits/posix/stat.h

// bits/posix/timer_t.h

// bits/posix/timeval.h

// bits/sigset_t.h

// bits/size_t.h

// bits/ssize_t.h

// bits/threads.h

// bits/types.h

// bits/wchar.h

// bits/wchar_t.h

// bits/wctrans_t.h

// bits/wctype_t.h

// bits/winsize.h
s! {
    pub struct winsize {
        pub ws_row: ::c_ushort,
        pub ws_col: ::c_ushort,
        pub ws_xpixel: ::c_ushort,
        pub ws_ypixel: ::c_ushort,
    }
}

// bits/wint_t.h

// ctype.h
extern "C" {
    pub fn isascii(__c: ::c_int) -> ::c_int;
}

// cykusz/syscall.h
pub const SYS_READ: ::c_int = 0;
pub const SYS_WRITE: ::c_int = 1;
pub const SYS_OPEN: ::c_int = 2;
pub const SYS_CLOSE: ::c_int = 3;
pub const SYS_CHDIR: ::c_int = 4;
pub const SYS_GETCWD: ::c_int = 5;
pub const SYS_MKDIR: ::c_int = 6;
pub const SYS_READDIR: ::c_int = 7;
pub const SYS_EXIT: ::c_int = 8;
pub const SYS_SLEEP: ::c_int = 9;
pub const SYS_BIND: ::c_int = 13;
pub const SYS_CONNECT: ::c_int = 14;
pub const SYS_SELECT: ::c_int = 15;
pub const SYS_MOUNT: ::c_int = 16;
pub const SYS_TIME: ::c_int = 18;
pub const SYS_SYMLINK: ::c_int = 19;
pub const SYS_RMDIR: ::c_int = 20;
pub const SYS_UNLINK: ::c_int = 21;
pub const SYS_LINK: ::c_int = 22;
pub const SYS_RENAME: ::c_int = 23;
pub const SYS_FORK: ::c_int = 24;
pub const SYS_EXEC: ::c_int = 25;
pub const SYS_FCNTL: ::c_int = 26;
pub const SYS_MMAP: ::c_int = 27;
pub const SYS_MUNMAP: ::c_int = 28;
pub const SYS_MAPS: ::c_int = 29;
pub const SYS_SEEK: ::c_int = 30;
pub const SYS_PREAD: ::c_int = 31;
pub const SYS_PWRITE: ::c_int = 32;
pub const SYS_WAITPID: ::c_int = 33;
pub const SYS_IOCTL: ::c_int = 34;
pub const SYS_SIGACTION: ::c_int = 35;
pub const SYS_SIGRETURN: ::c_int = 36;
pub const SYS_SIGPROCMASK: ::c_int = 37;
pub const SYS_FUTEX_WAIT: ::c_int = 38;
pub const SYS_FUTEX_WAKE: ::c_int = 39;
pub const SYS_ARCH_PRCTL: ::c_int = 40;
pub const SYS_SPAWN_THREAD: ::c_int = 41;
pub const SYS_EXIT_THREAD: ::c_int = 42;
pub const SYS_GETPID: ::c_int = 43;
pub const SYS_GETTID: ::c_int = 44;
pub const SYS_SETSID: ::c_int = 45;
pub const SYS_SETPGID: ::c_int = 46;
pub const SYS_PIPE: ::c_int = 47;
pub const SYS_DUP: ::c_int = 48;
pub const SYS_DUP2: ::c_int = 49;
pub const SYS_STAT: ::c_int = 50;
pub const SYS_READLINK: ::c_int = 51;
pub const SYS_GETRLIMIT: ::c_int = 52;
pub const SYS_DEBUG: ::c_int = 53;
pub const SYS_ACCESS: ::c_int = 54;
pub const SYS_KILL: ::c_int = 55;
pub const SYS_SYNC: ::c_int = 56;
pub const SYS_FSYNC: ::c_int = 57;
pub const SYS_TICKSNS: ::c_int = 58;
pub const SYS_GETPPID: ::c_int = 59;
pub const SYS_GETPGID: ::c_int = 60;
pub const SYS_TRUNCATE: ::c_int = 61;
pub const SYS_POLL: ::c_int = 62;
pub const SYS_SOCKET: ::c_int = 63;
pub const SYS_ACCEPT: ::c_int = 64;
pub const SYS_LISTEN: ::c_int = 65;
pub const SYS_MSGRECV: ::c_int = 66;
pub const SYS_MSGSEND: ::c_int = 67;
pub const SYS_SETSOCKOPT: ::c_int = 68;
pub const SYS_GETSOCKOPT: ::c_int = 69;
pub const SYS_YIELD: ::c_int = 70;
pub const SYS_CHMOD: ::c_int = 71;
pub const SYS_UTIME: ::c_int = 72;
pub const SYS_MKNODE: ::c_int = 73;
pub const SYS_SOCKETPAIR: ::c_int = 74;
pub const SYS_MPROTECT: ::c_int = 75;
pub type sc_word_t = ::c_long;
extern "C" {
    pub fn syscalln0(call: u64) -> ::c_long;
    pub fn syscalln1(call: u64, arg0: u64) -> ::c_long;
    pub fn syscalln2(call: u64, arg0: u64, arg1: u64) -> ::c_long;
    pub fn syscalln3(call: u64, arg0: u64, arg1: u64, arg2: u64) -> ::c_long;
    pub fn syscalln4(call: u64, arg0: u64, arg1: u64, arg2: u64, arg3: u64) -> ::c_long;
    pub fn syscalln5(call: u64, arg0: u64, arg1: u64, arg2: u64, arg3: u64, arg4: u64) -> ::c_long;
    pub fn syscalln6(
        call: u64,
        arg0: u64,
        arg1: u64,
        arg2: u64,
        arg3: u64,
        arg4: u64,
        arg5: u64,
    ) -> ::c_long;
}

// dirent.h
pub const DT_WHT: ::c_int = 14;
s! {
    pub struct dirent {
        pub d_ino: ::ino_t,
        pub d_off: ::off_t,
        pub d_reclen: ::c_ushort,
        pub d_type: ::c_uchar,
        pub d_name: [::c_char; 1024],
    }
    pub struct __mlibc_dir_struct {
        pub __handle: ::c_int,
        pub __ent_next: usize,
        pub __ent_limit: usize,
        pub __ent_buffer: [::c_char; 2048],
        pub __current: ::dirent,
    }
}
extern "C" {
    pub fn alphasort(__a: *const *mut ::dirent, __b: *const *mut ::dirent) -> ::c_int;
    pub fn readdir64(__dirp: *mut ::DIR) -> *mut ::dirent64;
    pub fn scandir(
        __pathname: *const ::c_char,
        __res: *mut *mut *mut ::dirent,
        __select: ::Option<unsafe extern "C" fn(*const ::dirent) -> ::c_int>,
        __compare: ::Option<
            unsafe extern "C" fn(*const *mut ::dirent, *const *mut ::dirent) -> ::c_int,
        >,
    ) -> ::c_int;
    pub fn seekdir(__dirp: *mut ::DIR, __loc: ::c_long);
    pub fn telldir(__dirp: *mut ::DIR) -> ::c_long;
    pub fn versionsort(__a: *const *mut ::dirent, __b: *const *mut ::dirent) -> ::c_int;
}

// errno.h
extern "C" {
    pub fn __errno_location() -> *mut ::c_int;
}

// error.h
extern "C" {
    pub fn error(__status: ::c_int, __errnum: ::c_int, __format: *const ::c_char, ...);
    pub fn error_at_line(
        __status: ::c_int,
        __errnum: ::c_int,
        __filename: *const ::c_char,
        __linenum: ::c_uint,
        __format: *const ::c_char,
        ...
    );
}

// execinfo.h
extern "C" {
    pub fn backtrace(__buffer: *mut *mut ::c_void, __size: ::c_int) -> ::c_int;
    pub fn backtrace_symbols(__buffer: *mut *mut ::c_void, __size: ::c_int) -> *mut *mut ::c_char;
    pub fn backtrace_symbols_fd(__buffer: *mut *mut ::c_void, __size: ::c_int, __fd: ::c_int);
}

// fcntl.h
pub const O_NDELAY: ::c_int = O_NONBLOCK;
pub const FALLOC_FL_KEEP_SIZE: ::c_int = 1;
pub const FALLOC_FL_PUNCH_HOLE: ::c_int = 2;
s! {
    pub struct flock {
        pub l_type: ::c_short,
        pub l_whence: ::c_short,
        pub l_start: ::off_t,
        pub l_len: ::off_t,
        pub l_pid: ::pid_t,
    }
    pub struct flock64 {
        pub l_type: ::c_short,
        pub l_whence: ::c_short,
        pub l_start: ::off_t,
        pub l_len: ::off_t,
        pub l_pid: ::pid_t,
    }
}
extern "C" {
    pub fn fallocate(__fd: ::c_int, __mode: ::c_int, __offset: ::off_t, __len: ::off_t) -> ::c_int;
    pub fn open64(__path: *const ::c_char, __flags: ::c_int, ...) -> ::c_int;
    pub fn posix_fallocate(__fd: ::c_int, __offset: ::off_t, __size: ::off_t) -> ::c_int;
}
s! {
    pub struct file_handle {
        pub handle_bytes: ::c_uint,
        pub handle_type: ::c_int,
        pub f_handle: [::c_uchar; 0],
    }
}
extern "C" {
    pub fn name_to_handle_at(
        __dirfd: ::c_int,
        __path: *const ::c_char,
        __handle: *mut ::file_handle,
        __mount_id: *mut ::c_int,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn open_by_handle_at(
        __dirfd: ::c_int,
        __handle: *mut ::file_handle,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn splice(
        __fd_in: ::c_int,
        __off_in: *mut ::off_t,
        __fd_out: ::c_int,
        __off_out: *mut ::off_t,
        __len: ::size_t,
        __flags: ::c_uint,
    ) -> ::ssize_t;
    pub fn vmsplice(
        __fd: ::c_int,
        __iov: *const ::iovec,
        __nr_segs: ::size_t,
        __flags: ::c_uint,
    ) -> ::ssize_t;
}

// features.h

// getopt.h
pub const no_argument: ::c_int = 0;
pub const required_argument: ::c_int = 1;
pub const optional_argument: ::c_int = 2;
s! {
    pub struct option {
        pub name: *const ::c_char,
        pub has_arg: ::c_int,
        pub flag: *mut ::c_int,
        pub val: ::c_int,
    }
}
extern "C" {
    pub fn getopt_long(
        __argc: ::c_int,
        __argv: *mut *mut ::c_char,
        __optstring: *const ::c_char,
        __longopts: *const option,
        __longindex: *mut ::c_int,
    ) -> ::c_int;
    pub fn getopt_long_only(
        __argc: ::c_int,
        __argv: *mut *mut ::c_char,
        __optstring: *const ::c_char,
        __longopts: *const option,
        __longindex: *mut ::c_int,
    ) -> ::c_int;
}

// glob.h
pub const GLOB_APPEND: ::c_int = 0x01;
pub const GLOB_DOOFFS: ::c_int = 0x02;
pub const GLOB_ERR: ::c_int = 0x04;
pub const GLOB_MARK: ::c_int = 0x08;
pub const GLOB_NOCHECK: ::c_int = 0x10;
pub const GLOB_NOESCAPE: ::c_int = 0x20;
pub const GLOB_NOSORT: ::c_int = 0x40;
pub const GLOB_PERIOD: ::c_int = 0x80;
pub const GLOB_TILDE: ::c_int = 0x100;
pub const GLOB_TILDE_CHECK: ::c_int = 0x200;
pub const GLOB_BRACE: ::c_int = 0x400;
pub const GLOB_NOMAGIC: ::c_int = 0x800;
pub const GLOB_ALTDIRFUNC: ::c_int = 0x1000;
pub const GLOB_ONLYDIR: ::c_int = 0x2000;
pub const GLOB_MAGCHAR: ::c_int = 0x4000;
pub const GLOB_ABORTED: ::c_int = 1;
pub const GLOB_NOMATCH: ::c_int = 2;
pub const GLOB_NOSPACE: ::c_int = 3;
pub const GLOB_NOSYS: ::c_int = 4;
s! {
    pub struct glob_t {
        pub gl_pathc: ::size_t,
        pub gl_pathv: *mut *mut ::c_char,
        pub gl_offs: ::size_t,
        pub gl_flags: ::c_int,
        pub gl_closedir: ::Option<unsafe extern "C" fn(*mut ::c_void) -> ::c_void>,
        pub gl_readdir: ::Option<unsafe extern "C" fn(*mut ::c_void) -> *mut ::dirent>,
        pub gl_opendir: ::Option<unsafe extern "C" fn(*const ::c_char) -> *mut ::c_void>,
        pub gl_lstat: ::Option<unsafe extern "C" fn(*const ::c_char, *mut ::stat) -> ::c_int>,
        pub gl_stat: ::Option<unsafe extern "C" fn(*const ::c_char, *mut ::stat) -> ::c_int>,
    }
}
extern "C" {
    pub fn glob(
        __pattern: *const ::c_char,
        __flags: ::c_int,
        __errfunc: ::Option<unsafe extern "C" fn(*const ::c_char, ::c_int) -> ::c_int>,
        __pglob: *mut ::glob_t,
    ) -> ::c_int;
    pub fn globfree(__pglog: *mut ::glob_t);
}

// grp.h
pub const BUFSIZ: ::c_int = 512;
pub const FOPEN_MAX: ::c_int = 1024;
pub const FILENAME_MAX: ::c_int = 256;
pub const L_tmpnam: ::c_int = 256;
pub const TMP_MAX: ::c_int = 1024;
s! {
    pub struct __mlibc_file_base {
        pub __buffer_ptr: *mut ::c_char,
        pub __buffer_size: ::size_t,
        pub __offset: ::size_t,
        pub __io_offset: ::size_t,
        pub __valid_limit: ::size_t,
        pub __dirty_begin: ::size_t,
        pub __dirty_end: ::size_t,
        pub __unget_ptr: *mut ::c_char,
        pub __io_mode: ::c_int,
        pub __status_bits: ::c_int,
    }
}
extern "C" {
    pub fn setlinebuf(__stream: *mut ::FILE);
    pub fn setbuffer(__stream: *mut ::FILE, __buffer: *mut ::c_char, __size: ::size_t);
    pub fn vfprintf(
        __stream: *mut ::FILE,
        __format: *const ::c_char,
        __args: *mut c_char,
    ) -> ::c_int;
    pub fn vfscanf(
        __stream: *mut ::FILE,
        __format: *const ::c_char,
        __args: *mut c_char,
    ) -> ::c_int;
    pub fn vprintf(__format: *const ::c_char, __args: *mut c_char) -> ::c_int;
    pub fn vscanf(__format: *const ::c_char, __args: *mut c_char) -> ::c_int;
    pub fn vsnprintf(
        __buffer: *mut ::c_char,
        __max_size: ::size_t,
        __format: *const ::c_char,
        __args: *mut c_char,
    ) -> ::c_int;
    pub fn vsprintf(
        __buffer: *mut ::c_char,
        __format: *const ::c_char,
        __args: *mut c_char,
    ) -> ::c_int;
    pub fn vsscanf(
        __buffer: *const ::c_char,
        __format: *const ::c_char,
        __args: *mut c_char,
    ) -> ::c_int;
    pub fn vasprintf(
        __buffer: *mut *mut ::c_char,
        __format: *const ::c_char,
        __args: *mut c_char,
    ) -> ::c_int;
    pub fn gets(__s: *mut ::c_char) -> *mut ::c_char;
    pub fn getc(__stream: *mut ::FILE) -> ::c_int;
    pub fn putc(__c: ::c_int, __stream: *mut ::FILE) -> ::c_int;
    pub fn getc_unlocked(__stream: *mut ::FILE) -> ::c_int;
    pub fn putc_unlocked(__c: ::c_int, __stream: *mut ::FILE) -> ::c_int;
    pub fn getdelim(
        __linep: *mut *mut ::c_char,
        __sizep: *mut ::size_t,
        __delim: ::c_int,
        __stream: *mut ::FILE,
    ) -> ::ssize_t;
    pub fn asprintf(__buffer: *mut *mut ::c_char, __format: *const ::c_char, ...) -> ::c_int;
    pub fn flockfile(__stream: *mut ::FILE);
    pub fn funlockfile(__stream: *mut ::FILE);
    pub fn ftrylockfile(__stream: *mut ::FILE) -> ::c_int;
    pub fn clearerr_unlocked(__stream: *mut ::FILE);
    pub fn feof_unlocked(__stream: *mut ::FILE) -> ::c_int;
    pub fn ferror_unlocked(__stream: *mut ::FILE) -> ::c_int;
    pub fn fileno_unlocked(__stream: *mut ::FILE) -> ::c_int;
    pub fn fflush_unlocked(__stream: *mut ::FILE) -> ::c_int;
    pub fn fgetc_unlocked(__stream: *mut ::FILE) -> ::c_int;
    pub fn fputc_unlocked(__c: ::c_int, __stream: *mut ::FILE) -> ::c_int;
    pub fn fread_unlocked(
        __buffer: *mut ::c_void,
        __size: ::size_t,
        __count: ::size_t,
        __stream: *mut ::FILE,
    ) -> ::size_t;
    pub fn fwrite_unlocked(
        __buffer: *const ::c_void,
        __size: ::size_t,
        __count: ::size_t,
        __stream: *mut ::FILE,
    ) -> ::size_t;
    pub fn fgets_unlocked(
        __buffer: *mut ::c_char,
        __size: ::c_int,
        __stream: *mut ::FILE,
    ) -> *mut ::c_char;
    pub fn fputs_unlocked(__buffer: *const ::c_char, __stream: *mut ::FILE) -> ::c_int;
}
s! {
    pub struct group {
        pub gr_name: *mut ::c_char,
        pub gr_passwd: *mut ::c_char,
        pub gr_gid: ::gid_t,
        pub gr_mem: *mut *mut ::c_char,
    }
}
extern "C" {
    pub fn endgrent();
    pub fn getgrent() -> *mut ::group;
    pub fn getgrgid(__gid: ::gid_t) -> *mut ::group;
    pub fn getgrgid_r(
        __gid: ::gid_t,
        __grp: *mut ::group,
        __buf: *mut ::c_char,
        __buflen: ::size_t,
        __res: *mut *mut ::group,
    ) -> ::c_int;
    pub fn getgrnam(__name: *const ::c_char) -> *mut ::group;
    pub fn getgrnam_r(
        __name: *const ::c_char,
        __grp: *mut ::group,
        __buf: *mut ::c_char,
        __buflen: ::size_t,
        __res: *mut *mut ::group,
    ) -> ::c_int;
    pub fn setgrent();
    pub fn putgrent(__grp: *const ::group, __stream: *mut ::FILE) -> ::c_int;
    pub fn fgetgrent(__stream: *mut ::FILE) -> *mut ::group;
    pub fn initgroups(__user: *const ::c_char, __group: ::gid_t) -> ::c_int;
    pub fn getgrouplist(
        __user: *const ::c_char,
        __group: ::gid_t,
        __groups: *mut ::gid_t,
        __ngroups: *mut ::c_int,
    ) -> ::c_int;
}

// ifaddrs.h

// langinfo.h
extern "C" {
    pub fn nl_langinfo(__item: ::nl_item) -> *mut ::c_char;
    pub fn nl_langinfo_l(__item: ::nl_item, __loc: ::locale_t) -> *mut ::c_char;
}

// libgen.h
extern "C" {
    pub fn basename(__path: *mut ::c_char) -> *mut ::c_char;
    pub fn dirname(__path: *mut ::c_char) -> *mut ::c_char;
}

// limits.h

// link.h
extern "C" {
    pub fn dl_iterate_phdr(
        __callback: ::Option<
            unsafe extern "C" fn(*mut ::dl_phdr_info, ::size_t, *mut ::c_void) -> ::c_int,
        >,
        __data: *mut ::c_void,
    ) -> ::c_int;
}

// linux/libc-compat.h

// malloc.h

// memory.h
extern "C" {
    pub fn strerror_r(__errnum: ::c_int, __buffer: *mut ::c_char, __size: ::size_t) -> ::c_int;
    pub fn mempcpy(
        __dest: *mut ::c_void,
        __src: *const ::c_void,
        __size: ::size_t,
    ) -> *mut ::c_void;
    pub fn strverscmp(__l0: *const ::c_char, __r0: *const ::c_char) -> ::c_int;
    pub fn ffsl(__i: ::c_long) -> ::c_int;
    pub fn ffsll(__i: ::c_longlong) -> ::c_int;
    pub fn memmem(
        __haystack: *const ::c_void,
        __haystacklen: ::size_t,
        __needle: *const ::c_void,
        __needlelen: ::size_t,
    ) -> *mut ::c_void;
}

// mntent.h
s! {
    pub struct mntent {
        pub mnt_fsname: *mut ::c_char,
        pub mnt_dir: *mut ::c_char,
        pub mnt_type: *mut ::c_char,
        pub mnt_opts: *mut ::c_char,
        pub mnt_freq: ::c_int,
        pub mnt_passno: ::c_int,
    }
}
extern "C" {
    pub fn setmntent(__filename: *const ::c_char, __type: *const ::c_char) -> *mut ::FILE;
    pub fn getmntent(__f: *mut ::FILE) -> *mut ::mntent;
    pub fn addmntent(__f: *mut ::FILE, __mnt: *const ::mntent) -> ::c_int;
    pub fn endmntent(__f: *mut ::FILE) -> ::c_int;
    pub fn hasmntopt(__mnt: *const ::mntent, __opt: *const ::c_char) -> *mut ::c_char;
    pub fn getmntent_r(
        __f: *mut ::FILE,
        __mnt: *mut ::mntent,
        __linebuf: *mut ::c_char,
        __buflen: ::c_int,
    ) -> *mut ::mntent;
}

// mqueue.h
pub type mqd_t = ::c_int;
extern "C" {
    pub fn mq_getattr(__mqdes: ::mqd_t, __attr: *mut ::mq_attr) -> ::c_int;
    pub fn mq_setattr(
        __mqdes: ::mqd_t,
        __newattr: *const ::mq_attr,
        __oldattr: *mut ::mq_attr,
    ) -> ::c_int;
    pub fn mq_unlink(__name: *const ::c_char) -> ::c_int;
    pub fn mq_open(__name: *const ::c_char, __flags: ::c_int, ...) -> ::mqd_t;
}

// net/if.h
pub const ALTIFNAMSIZ: ::c_int = 128;
pub const IFALIASZ: ::c_int = 256;
pub const IFHWADDRLEN: ::c_int = 6;
pub const IFF_BROADCAST: ::c_int = 0x2;
pub const IFF_LOOPBACK: ::c_int = 0x8;
pub const IFF_POINTOPOINT: ::c_int = 0x10;
pub const IFF_RUNNING: ::c_int = 0x40;
pub const IFF_MASTER: ::c_int = 0x400;
pub const IFF_SLAVE: ::c_int = 0x800;
pub const IFF_LOWER_UP: ::c_int = 0x10000;
pub const IFF_DORMANT: ::c_int = 0x20000;
pub const IFF_ECHO: ::c_int = 0x40000;
pub const IFF_VOLATILE: ::c_int = IFF_LOOPBACK
    | IFF_POINTOPOINT
    | IFF_BROADCAST
    | IFF_ECHO
    | IFF_MASTER
    | IFF_SLAVE
    | IFF_RUNNING
    | IFF_LOWER_UP
    | IFF_DORMANT;
s! {
    pub struct if_nameindex {
        pub if_index: ::c_uint,
        pub if_name: *mut ::c_char,
    }
    pub struct ifmap {
        pub mem_start: ::c_ulong,
        pub mem_end: ::c_ulong,
        pub base_addr: ::c_ushort,
        pub irq: ::c_uchar,
        pub dma: ::c_uchar,
        pub port: ::c_uchar,
    }
}
extern "C" {
    pub fn if_freenameindex(__index: *mut ::if_nameindex);
    pub fn if_nameindex() -> *mut ::if_nameindex;
}

// net/route.h
pub const RTF_HOST: ::c_int = 0x0004;
pub const RTF_REJECT: ::c_int = 0x0200;
s! {
    pub struct rtentry {
        pub rt_pad1: ::c_ulong,
        pub rt_dst: ::sockaddr,
        pub rt_gateway: ::sockaddr,
        pub rt_genmask: ::sockaddr,
        pub rt_flags: ::c_ushort,
        pub rt_pad2: ::c_short,
        pub rt_pad3: ::c_ulong,
        pub rt_tos: ::c_uchar,
        pub rt_class: ::c_uchar,
        pub rt_pad4: [::c_short; 3],
        pub rt_metric: ::c_short,
        pub rt_dev: *mut ::c_char,
        pub rt_mtu: ::c_ulong,
        pub rt_window: ::c_ulong,
        pub rt_irtt: ::c_ushort,
    }
}

// netdb.h
pub const AI_PASSIVE: ::c_int = 0x01;
pub const AI_CANONNAME: ::c_int = 0x02;
pub const AI_NUMERICHOST: ::c_int = 0x04;
pub const AI_V4MAPPED: ::c_int = 0x08;
pub const AI_ALL: ::c_int = 0x10;
pub const AI_ADDRCONFIG: ::c_int = 0x20;
pub const AI_NUMERICSERV: ::c_int = 0x40;
pub const NI_NOFQDN: ::c_int = 0x01;
pub const NI_NUMERICHOST: ::c_int = 0x02;
pub const NI_NAMEREQD: ::c_int = 0x04;
pub const NI_NUMERICSCOPE: ::c_int = 0x08;
pub const NI_DGRAM: ::c_int = 0x10;
pub const NI_NUMERICSERV: ::c_int = 2;
pub const NI_MAXSERV: ::c_int = 32;
pub const NI_IDN: ::c_int = 32;
pub const NI_IDN_USE_STD3_ASCII_RULES: ::c_int = 128;
pub const NI_MAXHOST: ::c_int = 1025;
pub const EAI_AGAIN: ::c_int = 1;
pub const EAI_BADFLAGS: ::c_int = 2;
pub const EAI_FAIL: ::c_int = 3;
pub const EAI_FAMILY: ::c_int = 4;
pub const EAI_MEMORY: ::c_int = 5;
pub const EAI_NONAME: ::c_int = 6;
pub const EAI_SERVICE: ::c_int = 7;
pub const EAI_SOCKTYPE: ::c_int = 8;
pub const EAI_SYSTEM: ::c_int = 9;
pub const EAI_OVERFLOW: ::c_int = 10;
pub const EAI_NODATA: ::c_int = 11;
pub const EAI_ADDRFAMILY: ::c_int = 12;
pub const HOST_NOT_FOUND: ::c_int = 1;
pub const TRY_AGAIN: ::c_int = 2;
pub const NO_RECOVERY: ::c_int = 3;
pub const NO_DATA: ::c_int = 4;
pub const NO_ADDRESS: ::c_int = NO_DATA;
s! {
    pub struct hostent {
        pub h_name: *mut ::c_char,
        pub h_aliases: *mut *mut ::c_char,
        pub h_addrtype: ::c_int,
        pub h_length: ::c_int,
        pub h_addr_list: *mut *mut ::c_char,
    }
    pub struct netent {
        pub n_name: *mut ::c_char,
        pub n_aliases: *mut *mut ::c_char,
        pub n_addrtype: ::c_int,
        pub n_net: u32,
    }
    pub struct protoent {
        pub p_name: *mut ::c_char,
        pub p_aliases: *mut *mut ::c_char,
        pub p_proto: ::c_int,
    }
    pub struct servent {
        pub s_name: *mut ::c_char,
        pub s_aliases: *mut *mut ::c_char,
        pub s_port: ::c_int,
        pub s_proto: *mut ::c_char,
    }
}
extern "C" {
    pub fn endhostent();
    pub fn endnetent();
    pub fn endprotoent();
    pub fn gethostent() -> *mut ::hostent;
    pub fn gethostbyname(__name: *const ::c_char) -> *mut ::hostent;
    pub fn gethostbyname2(__name: *const ::c_char, __flags: ::c_int) -> *mut ::hostent;
    pub fn gethostbyaddr(
        __addr: *const ::c_void,
        __len: ::socklen_t,
        __type: ::c_int,
    ) -> *mut ::hostent;
    pub fn gethostbyaddr_r(
        __addr: *const ::c_void,
        __len: ::socklen_t,
        __type: ::c_int,
        __ret: *mut ::hostent,
        __buf: *mut ::c_char,
        __buflen: ::size_t,
        __res: *mut *mut ::hostent,
        __h_errnump: *mut ::c_int,
    ) -> ::c_int;
    pub fn gethostbyname_r(
        __name: *const ::c_char,
        __ret: *mut ::hostent,
        __buf: *mut ::c_char,
        __buflen: ::size_t,
        __res: *mut *mut ::hostent,
        __h_errnump: *mut ::c_int,
    ) -> ::c_int;
    pub fn getnameinfo(
        __addr: *const ::sockaddr,
        __addrlen: ::socklen_t,
        __host: *mut ::c_char,
        __hostlen: ::socklen_t,
        __serv: *mut ::c_char,
        __servlen: ::socklen_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn getnetbyaddr(__net: u32, __type: ::c_int) -> *mut ::netent;
    pub fn getnetbyname(__name: *const ::c_char) -> *mut ::netent;
    pub fn getnetent() -> *mut ::netent;
    pub fn getprotoent() -> *mut ::protoent;
    pub fn sethostent(__stayopen: ::c_int);
    pub fn setnetent(__stayopen: ::c_int);
    pub fn setprotoent(__stayopen: ::c_int);
}

// netinet/ether.h
pub type __fd_mask = ::c_long;
pub type fd_mask = ::__fd_mask;
pub type u_int = ::c_uint;
pub type u_char = ::c_uchar;
pub type u_short = ::c_ushort;
pub type u_long = ::c_ulong;
pub type caddr_t = *mut ::c_char;
pub type loff_t = ::off64_t;
pub type ulong = ::c_ulong;
pub type ushort = ::c_ushort;
pub type uint = ::c_uint;
pub type u_int8_t = u8;
pub type u_int16_t = u16;
pub type u_int32_t = u32;
pub type u_int64_t = u64;
pub type quad_t = i64;
pub type u_quad_t = u64;
extern "C" {
    pub fn ether_ntoa(__addr: *const ::ether_addr) -> *mut ::c_char;
    pub fn ether_ntoa_r(__p_a: *const ::ether_addr, __x: *mut ::c_char) -> *mut ::c_char;
    pub fn ether_aton(__asc: *const ::c_char) -> *mut ::ether_addr;
}

// netinet/in.h

// netinet/in_systm.h

// netpacket/packet.h
pub const PACKET_BROADCAST: ::c_int = 1;
pub const PACKET_MULTICAST: ::c_int = 2;
pub const PACKET_OTHERHOST: ::c_int = 3;
pub const PACKET_OUTGOING: ::c_int = 4;
pub const PACKET_LOOPBACK: ::c_int = 5;
pub const PACKET_FASTROUTE: ::c_int = 6;
pub const PACKET_ADD_MEMBERSHIP: ::c_int = 1;
pub const PACKET_DROP_MEMBERSHIP: ::c_int = 2;
pub const PACKET_MR_MULTICAST: ::c_int = 0;
pub const PACKET_MR_PROMISC: ::c_int = 1;
pub const PACKET_MR_ALLMULTI: ::c_int = 2;
pub const PACKET_MR_UNICAST: ::c_int = 3;
s! {
    pub struct packet_mreq {
        pub mr_ifindex: ::c_int,
        pub mr_type: ::c_ushort,
        pub mr_alen: ::c_ushort,
        pub mr_address: [::c_uchar; 8],
    }
}

// nl_types.h

// poll.h
pub type nfds_t = usize;
s! {
    pub struct pollfd {
        pub fd: ::c_int,
        pub events: ::c_short,
        pub revents: ::c_short,
    }
}
extern "C" {
    pub fn ppoll(
        __fds: *mut ::pollfd,
        __nfds: ::nfds_t,
        __timeout_ts: *const ::timespec,
        __sigmask: *const ::sigset_t,
    ) -> ::c_int;
}

// pthread.h
pub const _NSIG: ::c_int = NSIG;
pub const SCHED_OTHER: ::c_int = 0;
pub const SCHED_FIFO: ::c_int = 1;
pub const SCHED_RR: ::c_int = 2;
pub const SCHED_BATCH: ::c_int = 3;
pub const SCHED_IDLE: ::c_int = 5;
pub const SCHED_DEADLINE: ::c_int = 6;
pub const SCHED_RESET_ON_FORK: ::c_int = 0x40000000;
pub const PTHREAD_SCOPE_SYSTEM: ::c_int = 0;
pub const PTHREAD_SCOPE_PROCESS: ::c_int = 1;
pub const PTHREAD_INHERIT_SCHED: ::c_int = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::c_int = 1;
pub const PTHREAD_CANCEL_DEFERRED: ::c_int = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::c_int = 1;
pub const PTHREAD_CANCEL_ENABLE: ::c_int = 0;
pub const PTHREAD_CANCEL_DISABLE: ::c_int = 1;
pub const PTHREAD_MUTEX_DEFAULT: ::c_int = __MLIBC_THREAD_MUTEX_DEFAULT;
pub const PTHREAD_MUTEX_NORMAL: ::c_int = __MLIBC_THREAD_MUTEX_NORMAL;
pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = __MLIBC_THREAD_MUTEX_ERRORCHECK;
pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = __MLIBC_THREAD_MUTEX_RECURSIVE;
pub const PTHREAD_MUTEX_STALLED: ::c_int = __MLIBC_THREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: ::c_int = __MLIBC_THREAD_MUTEX_ROBUST;
pub const PTHREAD_PROCESS_PRIVATE: ::c_int = __MLIBC_THREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: ::c_int = __MLIBC_THREAD_PROCESS_SHARED;
pub const PTHREAD_PRIO_NONE: ::c_int = __MLIBC_THREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: ::c_int = __MLIBC_THREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: ::c_int = __MLIBC_THREAD_PRIO_PROTECT;
pub const PTHREAD_BARRIER_SERIAL_THREAD: ::c_int = 1;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::c_int = 8;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: ::c_int = 1;
pub type sig_atomic_t = ::c_int;
extern "C" {
    pub fn sched_get_priority_max(__policy: ::c_int) -> ::c_int;
    pub fn sched_get_priority_min(__policy: ::c_int) -> ::c_int;
    pub fn sched_setscheduler(
        __pid: ::pid_t,
        __policy: ::c_int,
        __param: *const ::sched_param,
    ) -> ::c_int;
    pub fn sched_getparam(__pid: ::pid_t, __param: *mut ::sched_param) -> ::c_int;
}
pub type pthread_attr_t = ::__mlibc_threadattr;
pub type pthread_key_t = ::uintptr_t;
s! {
    pub struct __mlibc_once {
        pub __mlibc_done: ::c_uint,
    }
}
pub type pthread_once_t = ::__mlibc_once;
pub type pthread_mutexattr_t = ::__mlibc_mutexattr;
pub type pthread_mutex_t = ::__mlibc_mutex;
pub type pthread_condattr_t = ::__mlibc_condattr;
pub type pthread_cond_t = ::__mlibc_cond;
s! {
    pub struct __mlibc_barrierattr_struct {
        pub __mlibc_pshared: ::c_int,
    }
}
pub type pthread_barrierattr_t = ::__mlibc_barrierattr_struct;
s! {
    pub struct __mlibc_barrier {
        pub __mlibc_waiting: ::c_uint,
        pub __mlibc_inside: ::c_uint,
        pub __mlibc_count: ::c_uint,
        pub __mlibc_seq: ::c_uint,
        pub __mlibc_flags: ::c_uint,
    }
}
pub type pthread_barrier_t = ::__mlibc_barrier;
s! {
    pub struct __mlibc_fair_rwlock {
        #[doc(hidden)]
        size: [u8; 12],
    }
}
pub type pthread_rwlock_t = ::__mlibc_fair_rwlock;
s! {
    pub struct __mlibc_rwlockattr {
        pub __mlibc_pshared: ::c_int,
    }
}
pub type pthread_rwlockattr_t = ::__mlibc_rwlockattr;
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const ::pthread_attr_t,
        __state: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_attr_getstackaddr(
        __attr: *const ::pthread_attr_t,
        __stackaddr: *mut *mut ::c_void,
    ) -> ::c_int;
    pub fn pthread_attr_setstackaddr(
        __attr: *mut ::pthread_attr_t,
        __stackaddr: *mut ::c_void,
    ) -> ::c_int;
    pub fn pthread_attr_setstack(
        __attr: *mut ::pthread_attr_t,
        __stackaddr: *mut ::c_void,
        __stacksize: ::size_t,
    ) -> ::c_int;
    pub fn pthread_attr_getguardsize(
        __attr: *const ::pthread_attr_t,
        __guardsize: *mut ::size_t,
    ) -> ::c_int;
    pub fn pthread_attr_setguardsize(
        __attr: *mut ::pthread_attr_t,
        __guardsize: ::size_t,
    ) -> ::c_int;
    pub fn pthread_attr_getscope(__attr: *const ::pthread_attr_t, __scope: *mut ::c_int)
        -> ::c_int;
    pub fn pthread_attr_setscope(__attr: *mut ::pthread_attr_t, __scope: ::c_int) -> ::c_int;
    pub fn pthread_attr_getschedparam(
        __attr: *const ::pthread_attr_t,
        __param: *mut ::sched_param,
    ) -> ::c_int;
    pub fn pthread_attr_setschedparam(
        __attr: *mut ::pthread_attr_t,
        __param: *const ::sched_param,
    ) -> ::c_int;
    pub fn pthread_attr_getschedpolicy(
        __attr: *const ::pthread_attr_t,
        __schedpolicy: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut ::pthread_attr_t,
        __schedpolicy: ::c_int,
    ) -> ::c_int;
    pub fn pthread_attr_getinheritsched(
        __attr: *const ::pthread_attr_t,
        __inheritsched: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_attr_setinheritsched(
        __attr: *mut ::pthread_attr_t,
        __inheritsched: ::c_int,
    ) -> ::c_int;
    pub fn pthread_attr_getaffinity_np(
        __attr: *const ::pthread_attr_t,
        __cpusetsize: ::size_t,
        __cpuset: *mut ::cpu_set_t,
    ) -> ::c_int;
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut ::pthread_attr_t,
        __cpusetsize: ::size_t,
        __cpuset: *const ::cpu_set_t,
    ) -> ::c_int;
    pub fn pthread_attr_getsigmask_np(
        __attr: *const ::pthread_attr_t,
        __sigmask: *mut ::sigset_t,
    ) -> ::c_int;
    pub fn pthread_attr_setsigmask_np(
        __attr: *mut ::pthread_attr_t,
        __sigmask: *const ::sigset_t,
    ) -> ::c_int;
    pub fn pthread_getaffinity_np(
        __thrd: ::pthread_t,
        __cpusetsize: ::size_t,
        __cpuset: *mut ::cpu_set_t,
    ) -> ::c_int;
    pub fn pthread_setaffinity_np(
        __thrd: ::pthread_t,
        __cpusetsize: ::size_t,
        __cpuset: *const ::cpu_set_t,
    ) -> ::c_int;
    pub fn pthread_create(
        __thrd: *mut ::pthread_t,
        __attr: *const ::pthread_attr_t,
        __fn: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
        __arg: *mut ::c_void,
    ) -> ::c_int;
    pub fn pthread_equal(__a: ::pthread_t, __b: ::pthread_t) -> ::c_int;
    pub fn pthread_cleanup_push(
        __fn: ::Option<unsafe extern "C" fn(*mut ::c_void) -> ::c_void>,
        __arg: *mut ::c_void,
    );
    pub fn pthread_cleanup_pop(__execute: ::c_int);
    pub fn pthread_setname_np(__thrd: ::pthread_t, __name: *const ::c_char) -> ::c_int;
    pub fn pthread_getname_np(
        __thrd: ::pthread_t,
        __name: *mut ::c_char,
        __size: ::size_t,
    ) -> ::c_int;
    pub fn pthread_setschedparam(
        __thrd: ::pthread_t,
        __policy: ::c_int,
        __param: *const ::sched_param,
    ) -> ::c_int;
    pub fn pthread_getschedparam(
        __thrd: ::pthread_t,
        __policy: *mut ::c_int,
        __param: *mut ::sched_param,
    ) -> ::c_int;
    pub fn pthread_setcanceltype(__type: ::c_int, __oldtype: *mut ::c_int) -> ::c_int;
    pub fn pthread_setcancelstate(__state: ::c_int, __oldstate: *mut ::c_int) -> ::c_int;
    pub fn pthread_testcancel();
    pub fn pthread_cancel(__thrd: ::pthread_t) -> ::c_int;
    pub fn pthread_atfork(
        __prepare: ::Option<unsafe extern "C" fn() -> ::c_void>,
        __parent: ::Option<unsafe extern "C" fn() -> ::c_void>,
        __child: ::Option<unsafe extern "C" fn() -> ::c_void>,
    ) -> ::c_int;
    pub fn pthread_once(
        __once: *mut ::pthread_once_t,
        __fn: ::Option<unsafe extern "C" fn() -> ::c_void>,
    ) -> ::c_int;
    pub fn pthread_mutexattr_gettype(
        __attr: *const ::pthread_mutexattr_t,
        __type: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_getrobust(
        __attr: *const ::pthread_mutexattr_t,
        __robust: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut ::pthread_mutexattr_t,
        __robust: ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_getpshared(
        __attr: *const ::pthread_mutexattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const ::pthread_mutexattr_t,
        __protocol: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut ::pthread_mutexattr_t,
        __protocol: ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const ::pthread_mutexattr_t,
        __prioceiling: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut ::pthread_mutexattr_t,
        __prioceiling: ::c_int,
    ) -> ::c_int;
    pub fn pthread_mutex_timedlock(
        __mtx: *mut ::pthread_mutex_t,
        __abs_timeout: *const ::timespec,
    ) -> ::c_int;
    pub fn pthread_mutex_consistent(__mtx: *mut ::pthread_mutex_t) -> ::c_int;
    pub fn pthread_condattr_getpshared(
        __attr: *const ::pthread_condattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_barrierattr_init(__attr: *mut ::pthread_barrierattr_t) -> ::c_int;
    pub fn pthread_barrierattr_destroy(__attr: *mut ::pthread_barrierattr_t) -> ::c_int;
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut ::pthread_barrierattr_t,
        __pshared: ::c_int,
    ) -> ::c_int;
    pub fn pthread_barrierattr_getpshared(
        __attr: *const ::pthread_barrierattr_t,
        __pshared: *mut ::c_int,
    ) -> ::c_int;
    pub fn pthread_barrier_init(
        __barrier: *mut ::pthread_barrier_t,
        __attr: *const ::pthread_barrierattr_t,
        __count: ::c_uint,
    ) -> ::c_int;
    pub fn pthread_barrier_destroy(__barrier: *mut ::pthread_barrier_t) -> ::c_int;
    pub fn pthread_barrier_wait(__barrier: *mut ::pthread_barrier_t) -> ::c_int;
    pub fn pthread_getcpuclockid(__thrd: ::pthread_t, __clockid: *mut ::clockid_t) -> ::c_int;
}

// pwd.h
pub const NSS_BUFLEN_PASSWD: ::c_int = 512;
s! {
    pub struct passwd {
        pub pw_name: *mut ::c_char,
        pub pw_passwd: *mut ::c_char,
        pub pw_uid: ::uid_t,
        pub pw_gid: ::gid_t,
        pub pw_gecos: *mut ::c_char,
        pub pw_dir: *mut ::c_char,
        pub pw_shell: *mut ::c_char,
    }
}
extern "C" {
    pub fn endpwent();
    pub fn getpwent() -> *mut ::passwd;
    pub fn getpwnam_r(
        __name: *const ::c_char,
        __ret: *mut ::passwd,
        __buf: *mut ::c_char,
        __buflen: ::size_t,
        __res: *mut *mut ::passwd,
    ) -> ::c_int;
    pub fn getpwuid_r(
        __uid: ::uid_t,
        __ret: *mut ::passwd,
        __buf: *mut ::c_char,
        __buflen: ::size_t,
        __res: *mut *mut ::passwd,
    ) -> ::c_int;
    pub fn setpwent();
    pub fn putpwent(__pwd: *const ::passwd, __f: *mut ::FILE) -> ::c_int;
    pub fn fgetpwent(__f: *mut ::FILE) -> *mut ::passwd;
}

// regex.h
pub const REG_EXTENDED: ::c_int = 1;
pub const REG_ICASE: ::c_int = 2;
pub const REG_NEWLINE: ::c_int = 4;
pub const REG_NOSUB: ::c_int = 8;
pub const REG_NOTBOL: ::c_int = 1;
pub const REG_NOTEOL: ::c_int = 2;
pub const REG_OK: ::c_int = 0;
pub const REG_NOMATCH: ::c_int = 1;
pub const REG_BADPAT: ::c_int = 2;
pub const REG_ECOLLATE: ::c_int = 3;
pub const REG_ECTYPE: ::c_int = 4;
pub const REG_EESCAPE: ::c_int = 5;
pub const REG_ESUBREG: ::c_int = 6;
pub const REG_EBRACK: ::c_int = 7;
pub const REG_EPAREN: ::c_int = 8;
pub const REG_EBRACE: ::c_int = 9;
pub const REG_BADBR: ::c_int = 10;
pub const REG_ERANGE: ::c_int = 11;
pub const REG_ESPACE: ::c_int = 12;
pub const REG_BADRPT: ::c_int = 13;
pub const REG_ENOSYS: ::c_int = 1;
pub type regoff_t = ::ptrdiff_t;
s! {
    pub struct re_pattern_buffer {
        pub re_nsub: ::size_t,
        pub __opaque: *mut ::c_void,
        pub __padding: [*mut ::c_void; 4],
        pub __nsub2: ::size_t,
        pub __padding2: ::c_char,
    }
}
pub type regex_t = ::re_pattern_buffer;
s! {
    pub struct regmatch_t {
        pub rm_so: ::regoff_t,
        pub rm_eo: ::regoff_t,
    }
}
extern "C" {
    pub fn regcomp(
        __regex: *mut ::regex_t,
        __pattern: *const ::c_char,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn regexec(
        __regex: *const ::regex_t,
        __string: *const ::c_char,
        __nmatch: ::size_t,
        __pmatch: *mut ::regmatch_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn regerror(
        __errcode: ::c_int,
        __regex: *const ::regex_t,
        __errbuf: *mut ::c_char,
        __errbuf_size: ::size_t,
    ) -> ::size_t;
    pub fn regfree(__regex: *mut ::regex_t);
}

// sched.h

// scsi/scsi_ioctl.h

// semaphore.h
pub const SEM_VALUE_MAX: ::c_int = 0x7FFFFFFF;
s! {
    pub struct sem_ {
        pub __mlibc_count: ::c_uint,
    }
}
pub type sem_t = ::sem_;
extern "C" {
    pub fn sem_open(__name: *const ::c_char, __oflag: ::c_int, ...) -> *mut ::sem_t;
    pub fn sem_close(__sem: *mut ::sem_t) -> ::c_int;
    pub fn sem_unlink(__name: *const ::c_char) -> ::c_int;
    pub fn sem_timedwait(__sem: *mut ::sem_t, __abstime: *const ::timespec) -> ::c_int;
    pub fn sem_getvalue(__sem: *mut ::sem_t, __sval: *mut ::c_int) -> ::c_int;
}

// shadow.h
s! {
    pub struct spwd {
        pub sp_namp: *mut ::c_char,
        pub sp_pwdp: *mut ::c_char,
        pub sp_lstchg: i32,
        pub sp_min: i32,
        pub sp_max: i32,
        pub sp_warn: i32,
        pub sp_inact: i32,
        pub sp_expire: i32,
        pub sp_flag: u32,
    }
}
extern "C" {
    pub fn putspent(__sp: *const ::spwd, __f: *mut ::FILE) -> ::c_int;
    pub fn lckpwdf() -> ::c_int;
    pub fn ulckpwdf() -> ::c_int;
    pub fn getspnam(__name: *const ::c_char) -> *mut ::spwd;
    pub fn getspnam_r(
        __name: *const ::c_char,
        __sp: *mut ::spwd,
        __buf: *mut ::c_char,
        __size: ::size_t,
        __res: *mut *mut ::spwd,
    ) -> ::c_int;
    pub fn fgetspent(__f: *mut ::FILE) -> *mut ::spwd;
    pub fn endspent();
    pub fn sgetspent(__s: *const ::c_char) -> *mut ::spwd;
}

// signal.h

// spawn.h
pub const POSIX_SPAWN_RESETIDS: ::c_int = 1;
pub const POSIX_SPAWN_SETPGROUP: ::c_int = 2;
pub const POSIX_SPAWN_SETSIGDEF: ::c_int = 4;
pub const POSIX_SPAWN_SETSIGMASK: ::c_int = 8;
pub const POSIX_SPAWN_SETSCHEDPARAM: ::c_int = 16;
pub const POSIX_SPAWN_SETSCHEDULER: ::c_int = 32;
pub const POSIX_SPAWN_USEVFORK: ::c_int = 64;
pub const POSIX_SPAWN_SETSID: ::c_int = 128;
s! {
    pub struct posix_spawnattr_t {
        pub __flags: ::c_int,
        pub __pgrp: ::pid_t,
        pub __def: ::sigset_t,
        pub __mask: ::sigset_t,
        pub __prio: ::c_int,
        pub __pol: ::c_int,
        pub __fn: *mut ::c_void,
        pub __pad: [::c_char; 56],
    }
}
s! {
    pub struct posix_spawn_file_actions_t {
        pub __pad0: [::c_int; 2],
        pub __actions: *mut ::c_void,
        pub __pad: [::c_int; 16],
    }
}
extern "C" {
    pub fn posix_spawn(
        __pid: *mut ::pid_t,
        __path: *const ::c_char,
        __file_actions: *const ::posix_spawn_file_actions_t,
        __attrs: *const ::posix_spawnattr_t,
        __argv: *mut *mut ::c_char,
        __envp: *mut *mut ::c_char,
    ) -> ::c_int;
    pub fn posix_spawnattr_init(__attr: *mut ::posix_spawnattr_t) -> ::c_int;
    pub fn posix_spawnattr_destroy(__attr: *mut ::posix_spawnattr_t) -> ::c_int;
    pub fn posix_spawnattr_setflags(
        __attr: *mut ::posix_spawnattr_t,
        __flags: ::c_short,
    ) -> ::c_int;
    pub fn posix_spawnattr_setsigdefault(
        __attr: *mut ::posix_spawnattr_t,
        __sigdefault: *const ::sigset_t,
    ) -> ::c_int;
    pub fn posix_spawnattr_setschedparam(
        __attr: *mut ::posix_spawnattr_t,
        __schedparam: *const ::sched_param,
    ) -> ::c_int;
    pub fn posix_spawnattr_setschedpolicy(
        __attr: *mut ::posix_spawnattr_t,
        __schedpolicy: ::c_int,
    ) -> ::c_int;
    pub fn posix_spawnattr_setsigmask(
        __attr: *mut ::posix_spawnattr_t,
        __sigmask: *const ::sigset_t,
    ) -> ::c_int;
    pub fn posix_spawnattr_setpgroup(
        __attr: *mut ::posix_spawnattr_t,
        __pgroup: ::pid_t,
    ) -> ::c_int;
    pub fn posix_spawn_file_actions_init(
        __file_actions: *mut ::posix_spawn_file_actions_t,
    ) -> ::c_int;
    pub fn posix_spawn_file_actions_destroy(
        __file_actions: *mut ::posix_spawn_file_actions_t,
    ) -> ::c_int;
    pub fn posix_spawn_file_actions_adddup2(
        __file_actions: *mut ::posix_spawn_file_actions_t,
        __fildes: ::c_int,
        __newfildes: ::c_int,
    ) -> ::c_int;
    pub fn posix_spawn_file_actions_addclose(
        __file_actions: *mut ::posix_spawn_file_actions_t,
        __fildes: ::c_int,
    ) -> ::c_int;
    pub fn posix_spawn_file_actions_addopen(
        __file_actions: *mut ::posix_spawn_file_actions_t,
        __fildes: ::c_int,
        __path: *const ::c_char,
        __oflag: ::c_int,
        __mode: ::mode_t,
    ) -> ::c_int;
    pub fn posix_spawnp(
        __pid: *mut ::pid_t,
        __file: *const ::c_char,
        __file_actions: *const ::posix_spawn_file_actions_t,
        __attrp: *const ::posix_spawnattr_t,
        __argv: *mut *mut ::c_char,
        __envp: *mut *mut ::c_char,
    ) -> ::c_int;
}

// stdc-predef.h

// stdio.h

// stdio_ext.h
pub const FSETLOCKING_INTERNAL: ::c_int = 1;
pub const FSETLOCKING_BYCALLER: ::c_int = 2;
pub const FSETLOCKING_QUERY: ::c_int = 3;
extern "C" {
    pub fn _flushlbf();
}

// stdlib.h

// string.h

// sys/auxv.h
extern "C" {
    pub fn peekauxval(__type: ::c_ulong, __value: *mut ::c_ulong) -> ::c_int;
    pub fn getauxval(__type: ::c_ulong) -> ::c_ulong;
}

// sys/cachectl.h

// sys/endian.h

// sys/epoll.h
pub const EPOLL_NONBLOCK: ::c_int = O_NONBLOCK;
extern "C" {
    pub fn epoll_create(__flags: ::c_int) -> ::c_int;
    pub fn epoll_create1(__flags: ::c_int) -> ::c_int;
    pub fn epoll_ctl(
        __epfd: ::c_int,
        __mode: ::c_int,
        __fd: ::c_int,
        __ev: *mut ::epoll_event,
    ) -> ::c_int;
    pub fn epoll_wait(
        __epfd: ::c_int,
        __events: *mut ::epoll_event,
        __maxevents: ::c_int,
        __timeout: ::c_int,
    ) -> ::c_int;
    pub fn epoll_pwait(
        __epfd: ::c_int,
        __events: *mut ::epoll_event,
        __maxevents: ::c_int,
        __timeout: ::c_int,
        __sigmask: *const ::sigset_t,
    ) -> ::c_int;
}

// sys/errno.h

// sys/eventfd.h
pub const EFD_SEMAPHORE: ::c_int = 1;
pub const EFD_CLOEXEC: ::c_int = O_CLOEXEC;
pub const EFD_NONBLOCK: ::c_int = O_NONBLOCK;
pub type eventfd_t = u64;
extern "C" {
    pub fn eventfd(__initval: ::c_uint, __flags: ::c_int) -> ::c_int;
    pub fn eventfd_read(__fd: ::c_int, __value: *mut ::eventfd_t) -> ::c_int;
    pub fn eventfd_write(__fd: ::c_int, __value: ::eventfd_t) -> ::c_int;
}

// sys/file.h
extern "C" {
    pub fn flock64(__fd: ::c_int, __op: ::c_int) -> ::c_int;
}

// sys/fsuid.h
extern "C" {
    pub fn setfsuid(__uid: ::uid_t) -> ::c_int;
    pub fn setfsgid(__gid: ::gid_t) -> ::c_int;
}

// sys/inotify.h
pub const IN_ACCESS: ::c_int = 0x1;
pub const IN_ATTRIB: ::c_int = 0x4;
pub const IN_CLOSE_WRITE: ::c_int = 0x8;
pub const IN_CLOSE_NOWRITE: ::c_int = 0x10;
pub const IN_CREATE: ::c_int = 0x100;
pub const IN_DELETE: ::c_int = 0x200;
pub const IN_DELETE_SELF: ::c_int = 0x400;
pub const IN_MODIFY: ::c_int = 0x2;
pub const IN_MOVE_SELF: ::c_int = 0x800;
pub const IN_MOVED_FROM: ::c_int = 0x40;
pub const IN_MOVED_TO: ::c_int = 0x80;
pub const IN_OPEN: ::c_int = 0x20;
pub const IN_MOVE: ::c_int = IN_MOVED_FROM | IN_MOVED_TO;
pub const IN_CLOSE: ::c_int = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;
pub const IN_DONT_FOLLOW: ::c_int = 0x2000000;
pub const IN_EXCL_UNLINK: ::c_int = 0x4000000;
pub const IN_MASK_ADD: ::c_int = 0x20000000;
pub const IN_ONESHOT: ::c_int = 0x80000000;
pub const IN_ONLYDIR: ::c_int = 0x1000000;
pub const IN_IGNORED: ::c_int = 0x8000;
pub const IN_ISDIR: ::c_int = 0x40000000;
pub const IN_Q_OVERFLOW: ::c_int = 0x4000;
pub const IN_UNMOUNT: ::c_int = 0x2000;
pub const IN_ALL_EVENTS: ::c_int = IN_ACCESS
    | IN_MODIFY
    | IN_ATTRIB
    | IN_CLOSE_WRITE
    | IN_CLOSE_NOWRITE
    | IN_OPEN
    | IN_MOVED_FROM
    | IN_MOVED_TO
    | IN_DELETE
    | IN_CREATE
    | IN_DELETE_SELF
    | IN_MOVE_SELF;
s! {
    pub struct inotify_event {
        pub wd: ::c_int,
        pub mask: ::c_uint,
        pub cookie: ::c_uint,
        pub len: ::c_uint,
        pub name: *mut ::c_char,
    }
}
extern "C" {
    pub fn inotify_init() -> ::c_int;
    pub fn inotify_init1(__flags: ::c_int) -> ::c_int;
    pub fn inotify_add_watch(__ifd: ::c_int, __path: *const ::c_char, __mask: u32) -> ::c_int;
    pub fn inotify_rm_watch(__ifd: ::c_int, __wd: ::c_int) -> ::c_int;
}

// sys/io.h
extern "C" {
    pub fn ioperm(__from: ::c_ulong, __num: ::c_ulong, __turn_on: ::c_int) -> ::c_int;
    pub fn iopl(__level: ::c_int) -> ::c_int;
    pub fn inb(__port: ::c_ushort) -> ::c_uchar;
    pub fn inb_p(__port: ::c_ushort) -> ::c_uchar;
    pub fn inw(__port: ::c_ushort) -> ::c_ushort;
    pub fn inw_p(__port: ::c_ushort) -> ::c_ushort;
    pub fn inl(__port: ::c_ushort) -> ::c_uint;
    pub fn inl_p(__port: ::c_ushort) -> ::c_uint;
    pub fn outb(value: ::c_uchar, __port: ::c_ushort);
    pub fn outb_p(__value: ::c_uchar, __port: ::c_ushort);
    pub fn outw(__value: ::c_ushort, __port: ::c_ushort);
    pub fn outw_p(__value: ::c_ushort, __port: ::c_ushort);
    pub fn outl(__value: ::c_uint, __port: ::c_ushort);
    pub fn outl_p(__value: ::c_uint, __port: ::c_ushort);
    pub fn insb(__port: ::c_ushort, __addr: *mut ::c_void, __count: ::c_ulong);
    pub fn insw(__port: ::c_ushort, __addr: *mut ::c_void, __count: ::c_ulong);
    pub fn insl(__port: ::c_ushort, __addr: *mut ::c_void, __count: ::c_ulong);
    pub fn outsb(__port: ::c_ushort, __addr: *const ::c_void, __count: ::c_ulong);
    pub fn outsw(__port: ::c_ushort, __addr: *const ::c_void, __count: ::c_ulong);
    pub fn outsl(__port: ::c_ushort, __addr: *const ::c_void, __count: ::c_ulong);
}

// sys/ioctl.h
pub const FIONREAD: ::c_ulong = 0x541B;
pub const FIONBIO: ::c_ulong = 0x5421;
pub const FIONCLEX: ::c_ulong = 0x5450;
pub const FIOCLEX: ::c_ulong = 0x5451;
pub const SIOCGIFMTU: ::c_ulong = 0x8921;
pub const SIOCSIFMTU: ::c_ulong = 0x8922;
pub const SIOCDEVPRIVATE: ::c_ulong = 0x89F0;
extern "C" {
    pub fn ioctl(__fd: ::c_int, __request: ::c_ulong, ...) -> ::c_int;
}

// sys/ipc.h

// sys/kd.h

// sys/klog.h
extern "C" {
    pub fn klogctl(__type: ::c_int, __bufp: *mut ::c_char, __len: ::c_int) -> ::c_int;
}

// sys/mman.h
extern "C" {
    pub fn mmap64(
        __addr: *mut ::c_void,
        __size: ::size_t,
        __prot: ::c_int,
        __flags: ::c_int,
        __fd: ::c_int,
        __offset: ::off64_t,
    ) -> *mut ::c_void;
    pub fn mprotect(__addr: *mut ::c_void, __size: ::size_t, __prot: ::c_int) -> ::c_int;
    pub fn posix_madvise(__addr: *mut ::c_void, __size: ::size_t, __advise: ::c_int) -> ::c_int;
    pub fn msync(__addr: *mut ::c_void, __size: ::size_t, __flags: ::c_int) -> ::c_int;
    pub fn shm_open(__name: *const ::c_char, __oflag: ::c_int, __mode: ::mode_t) -> ::c_int;
    pub fn shm_unlink(__name: *const ::c_char) -> ::c_int;
    pub fn mremap(
        __old_address: *mut ::c_void,
        __old_size: ::size_t,
        __new_size: ::size_t,
        __flags: ::c_int,
        ...
    ) -> *mut ::c_void;
    pub fn remap_file_pages(
        __addr: *mut ::c_void,
        __size: ::size_t,
        __prot: ::c_int,
        __pgoff: ::size_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn memfd_create(__name: *const ::c_char, __flags: ::c_uint) -> ::c_int;
    pub fn madvise(__addr: *mut ::c_void, __size: ::size_t, __advise: ::c_int) -> ::c_int;
}

// sys/msg.h
extern "C" {
    pub fn msgget(__key: ::key_t, __msgflg: ::c_int) -> ::c_int;
    pub fn msgctl(__msqid: ::c_int, __cmd: ::c_int, __buf: *mut ::msqid64_ds) -> ::c_int;
    pub fn msgrcv(
        __msqid: ::c_int,
        __msgp: *mut ::c_void,
        __size: ::size_t,
        __msgtyp: ::c_long,
        __msgflg: ::c_int,
    ) -> ::ssize_t;
    pub fn msgsnd(
        __msqid: ::c_int,
        __msgp: *const ::c_void,
        __size: ::size_t,
        __msgflg: ::c_int,
    ) -> ::c_int;
}

// sys/personality.h
extern "C" {
    pub fn personality(__persona: ::c_ulong) -> ::c_int;
}

// sys/poll.h

// sys/prctl.h
pub const PR_SET_PDEATHSIG: ::c_int = 1;
pub const PR_GET_PDEATHSIG: ::c_int = 2;
pub const PR_GET_DUMPABLE: ::c_int = 3;
pub const PR_SET_DUMPABLE: ::c_int = 4;
pub const PR_GET_UNALIGN: ::c_int = 5;
pub const PR_SET_UNALIGN: ::c_int = 6;
pub const PR_UNALIGN_NOPRINT: ::c_int = 1;
pub const PR_UNALIGN_SIGBUS: ::c_int = 2;
pub const PR_GET_KEEPCAPS: ::c_int = 7;
pub const PR_SET_KEEPCAPS: ::c_int = 8;
pub const PR_GET_FPEMU: ::c_int = 9;
pub const PR_SET_FPEMU: ::c_int = 10;
pub const PR_FPEMU_NOPRINT: ::c_int = 1;
pub const PR_FPEMU_SIGFPE: ::c_int = 2;
pub const PR_GET_FPEXC: ::c_int = 11;
pub const PR_SET_FPEXC: ::c_int = 12;
pub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;
pub const PR_FP_EXC_DIV: ::c_int = 0x010000;
pub const PR_FP_EXC_OVF: ::c_int = 0x020000;
pub const PR_FP_EXC_UND: ::c_int = 0x040000;
pub const PR_FP_EXC_RES: ::c_int = 0x080000;
pub const PR_FP_EXC_INV: ::c_int = 0x100000;
pub const PR_FP_EXC_DISABLED: ::c_int = 0;
pub const PR_FP_EXC_NONRECOV: ::c_int = 1;
pub const PR_FP_EXC_ASYNC: ::c_int = 2;
pub const PR_FP_EXC_PRECISE: ::c_int = 3;
pub const PR_GET_TIMING: ::c_int = 13;
pub const PR_SET_TIMING: ::c_int = 14;
pub const PR_TIMING_STATISTICAL: ::c_int = 0;
pub const PR_TIMING_TIMESTAMP: ::c_int = 1;
pub const PR_SET_NAME: ::c_int = 15;
pub const PR_GET_NAME: ::c_int = 16;
pub const PR_GET_ENDIAN: ::c_int = 19;
pub const PR_SET_ENDIAN: ::c_int = 20;
pub const PR_ENDIAN_BIG: ::c_int = 0;
pub const PR_ENDIAN_LITTLE: ::c_int = 1;
pub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;
pub const PR_GET_SECCOMP: ::c_int = 21;
pub const PR_SET_SECCOMP: ::c_int = 22;
pub const PR_CAPBSET_READ: ::c_int = 23;
pub const PR_CAPBSET_DROP: ::c_int = 24;
pub const PR_GET_TSC: ::c_int = 25;
pub const PR_SET_TSC: ::c_int = 26;
pub const PR_TSC_ENABLE: ::c_int = 1;
pub const PR_TSC_SIGSEGV: ::c_int = 2;
pub const PR_GET_SECUREBITS: ::c_int = 27;
pub const PR_SET_SECUREBITS: ::c_int = 28;
pub const PR_SET_TIMERSLACK: ::c_int = 29;
pub const PR_GET_TIMERSLACK: ::c_int = 30;
pub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;
pub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;
pub const PR_MCE_KILL: ::c_int = 33;
pub const PR_MCE_KILL_CLEAR: ::c_int = 0;
pub const PR_MCE_KILL_SET: ::c_int = 1;
pub const PR_MCE_KILL_LATE: ::c_int = 0;
pub const PR_MCE_KILL_EARLY: ::c_int = 1;
pub const PR_MCE_KILL_DEFAULT: ::c_int = 2;
pub const PR_MCE_KILL_GET: ::c_int = 34;
pub const PR_SET_MM: ::c_int = 35;
pub const PR_SET_MM_START_CODE: ::c_int = 1;
pub const PR_SET_MM_END_CODE: ::c_int = 2;
pub const PR_SET_MM_START_DATA: ::c_int = 3;
pub const PR_SET_MM_END_DATA: ::c_int = 4;
pub const PR_SET_MM_START_STACK: ::c_int = 5;
pub const PR_SET_MM_START_BRK: ::c_int = 6;
pub const PR_SET_MM_BRK: ::c_int = 7;
pub const PR_SET_MM_ARG_START: ::c_int = 8;
pub const PR_SET_MM_ARG_END: ::c_int = 9;
pub const PR_SET_MM_ENV_START: ::c_int = 10;
pub const PR_SET_MM_ENV_END: ::c_int = 11;
pub const PR_SET_MM_AUXV: ::c_int = 12;
pub const PR_SET_MM_EXE_FILE: ::c_int = 13;
pub const PR_SET_MM_MAP: ::c_int = 14;
pub const PR_SET_MM_MAP_SIZE: ::c_int = 15;
pub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;
pub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;
pub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;
pub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;
pub const PR_GET_TID_ADDRESS: ::c_int = 40;
pub const PR_SET_THP_DISABLE: ::c_int = 41;
pub const PR_GET_THP_DISABLE: ::c_int = 42;
pub const PR_MPX_ENABLE_MANAGEMENT: ::c_int = 43;
pub const PR_MPX_DISABLE_MANAGEMENT: ::c_int = 44;
pub const PR_SET_FP_MODE: ::c_int = 45;
pub const PR_GET_FP_MODE: ::c_int = 46;
pub const PR_FP_MODE_FR: ::c_int = 1 << 0;
pub const PR_FP_MODE_FRE: ::c_int = 1 << 1;
pub const PR_CAP_AMBIENT: ::c_int = 47;
pub const PR_CAP_AMBIENT_IS_SET: ::c_int = 1;
pub const PR_CAP_AMBIENT_RAISE: ::c_int = 2;
pub const PR_CAP_AMBIENT_LOWER: ::c_int = 3;
pub const PR_CAP_AMBIENT_CLEAR_ALL: ::c_int = 4;
extern "C" {
    pub fn prctl(__op: ::c_int, ...) -> ::c_int;
}

// sys/ptrace.h
pub const PTRACE_TRACEME: ::c_int = 0;
pub const PT_TRACE_ME: ::c_int = PTRACE_TRACEME;
pub const PT_READ_I: ::c_int = PTRACE_PEEKTEXT;
pub const PT_READ_D: ::c_int = PTRACE_PEEKDATA;
pub const PT_READ_U: ::c_int = PTRACE_PEEKUSER;
pub const PT_WRITE_I: ::c_int = PTRACE_POKETEXT;
pub const PT_WRITE_D: ::c_int = PTRACE_POKEDATA;
pub const PT_WRITE_U: ::c_int = PTRACE_POKEUSER;
pub const PT_CONTINUE: ::c_int = PTRACE_CONT;
pub const PT_KILL: ::c_int = PTRACE_KILL;
pub const PT_STEP: ::c_int = PTRACE_SINGLESTEP;
pub const PT_GETREGS: ::c_int = PTRACE_GETREGS;
pub const PT_SETREGS: ::c_int = PTRACE_SETREGS;
pub const PT_GETFPREGS: ::c_int = PTRACE_GETFPREGS;
pub const PT_SETFPREGS: ::c_int = PTRACE_SETFPREGS;
pub const PT_ATTACH: ::c_int = PTRACE_ATTACH;
pub const PT_DETACH: ::c_int = PTRACE_DETACH;
pub const PT_GETFPXREGS: ::c_int = PTRACE_GETFPXREGS;
pub const PT_SETFPXREGS: ::c_int = PTRACE_SETFPXREGS;
pub const PT_SYSCALL: ::c_int = PTRACE_SYSCALL;
pub const PT_SETOPTIONS: ::c_int = PTRACE_SETOPTIONS;
pub const PT_GETEVENTMSG: ::c_int = PTRACE_GETEVENTMSG;
pub const PT_GETSIGINFO: ::c_int = PTRACE_GETSIGINFO;
pub const PT_SETSIGINFO: ::c_int = PTRACE_SETSIGINFO;
s! {
    pub struct ptrace_peeksiginfo_args {
        pub offset: u64,
        pub flags: u32,
        pub nr: i32,
    }
}
extern "C" {
    pub fn ptrace(__op: ::c_int, ...) -> ::c_long;
}

// sys/quota.h
extern "C" {
    pub fn quotactl(
        __cmd: ::c_int,
        __special: *const ::c_char,
        __id: ::c_int,
        __addr: ::caddr_t,
    ) -> ::c_int;
}

// sys/random.h
pub const GRND_RANDOM: ::c_int = 1;
pub const GRND_NONBLOCK: ::c_int = 2;
extern "C" {
    pub fn getrandom(__buffer: *mut ::c_void, __max_size: ::size_t, __flags: ::c_uint)
        -> ::ssize_t;
}

// sys/reboot.h
extern "C" {
    pub fn reboot(__arg: ::c_int) -> ::c_int;
}

// sys/reg.h
pub const R15: ::c_int = 0;
pub const R14: ::c_int = 1;
pub const R13: ::c_int = 2;
pub const R12: ::c_int = 3;
pub const RBP: ::c_int = 4;
pub const RBX: ::c_int = 5;
pub const R11: ::c_int = 6;
pub const R10: ::c_int = 7;
pub const R9: ::c_int = 8;
pub const R8: ::c_int = 9;
pub const RAX: ::c_int = 10;
pub const RCX: ::c_int = 11;
pub const RDX: ::c_int = 12;
pub const RSI: ::c_int = 13;
pub const RDI: ::c_int = 14;
pub const ORIG_RAX: ::c_int = 15;
pub const RIP: ::c_int = 16;
pub const CS: ::c_int = 17;
pub const EFLAGS: ::c_int = 18;
pub const RSP: ::c_int = 19;
pub const SS: ::c_int = 20;
pub const FS_BASE: ::c_int = 21;
pub const GS_BASE: ::c_int = 22;
pub const DS: ::c_int = 23;
pub const ES: ::c_int = 24;
pub const FS: ::c_int = 25;
pub const GS: ::c_int = 26;

// sys/resource.h
pub const PRIO_PROCESS: ::c_int = 1;
pub const PRIO_PGRP: ::c_int = 2;
pub const PRIO_USER: ::c_int = 3;
pub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;
pub type rlim_t = ::c_ulonglong;
s! {
    pub struct rlimit {
        pub rlim_cur: ::rlim_t,
        pub rlim_max: ::rlim_t,
    }
}
extern "C" {
    pub fn getpriority(__which: ::c_int, __who: ::id_t) -> ::c_int;
    pub fn setpriority(__which: ::c_int, __who: ::id_t, __prio: ::c_int) -> ::c_int;
    pub fn getrlimit(__resource: ::c_int, __rlim: *mut ::rlimit) -> ::c_int;
    pub fn getrlimit64(__resource: ::c_int, __rlim: *mut ::rlimit) -> ::c_int;
    pub fn setrlimit(__resource: ::c_int, __rlim: *const ::rlimit) -> ::c_int;
    pub fn setrlimit64(__resource: ::c_int, __rlim: *const ::rlimit) -> ::c_int;
    pub fn prlimit(
        __pid: ::pid_t,
        __resource: ::c_int,
        __new_limits: *const ::rlimit,
        __old_limits: *mut ::rlimit,
    ) -> ::c_int;
}

// sys/select.h

// sys/sem.h
pub const GETPID: ::c_int = 11;
pub const GETVAL: ::c_int = 12;
pub const GETALL: ::c_int = 13;
pub const SETVAL: ::c_int = 16;
pub const SETALL: ::c_int = 17;
pub const SEM_UNDO: ::c_int = 0x1000;
s! {
    pub struct sembuf {
        pub sem_num: ::c_ushort,
        pub sem_op: ::c_short,
        pub sem_flg: ::c_short,
    }
    pub struct semid_ds {
        pub sem_perm: ::ipc64_perm,
        pub sem_otime: ::time_t,
        pub sem_ctime: ::time_t,
        pub sem_nsems: ::c_ulong,
    }
}
extern "C" {
    pub fn semget(__key: ::key_t, __nsems: ::c_int, __semflg: ::c_int) -> ::c_int;
    pub fn semop(__semid: ::c_int, __sops: *mut ::sembuf, __nsops: ::size_t) -> ::c_int;
    pub fn semctl(__semid: ::c_int, __semnum: ::c_int, __op: ::c_int, ...) -> ::c_int;
}

// sys/sendfile.h
extern "C" {
    pub fn sendfile(
        __out_fd: ::c_int,
        __in_fd: ::c_int,
        __offset: *mut ::off_t,
        __size: ::size_t,
    ) -> ::ssize_t;
}

// sys/shm.h
pub const SHM_R: ::c_int = 0o400;
pub const SHM_W: ::c_int = 0o200;
pub const SHM_RDONLY: ::c_int = 0o10000;
pub const SHM_RND: ::c_int = 0o20000;
pub const SHM_REMAP: ::c_int = 0o40000;
pub const SHM_EXEC: ::c_int = 0o100000;
pub const SHM_LOCK: ::c_int = 11;
pub const SHM_UNLOCK: ::c_int = 12;
pub const SHM_STAT: ::c_int = 13;
pub const SHM_INFO: ::c_int = 14;
pub const SHM_STAT_ANY: ::c_int = 15;
pub const SHM_DEST: ::c_int = 0o1000;
pub const SHM_LOCKED: ::c_int = 0o2000;
pub const SHM_HUGETLB: ::c_int = 0o4000;
pub const SHM_NORESERVE: ::c_int = 0o10000;
pub const SHM_HUGE_SHIFT: ::c_int = 26;
pub const SHM_HUGE_MASK: ::c_int = 0x3f;
pub const SHM_HUGE_64KB: ::c_int = 16 << 26;
pub const SHM_HUGE_512KB: ::c_int = 19 << 26;
pub const SHM_HUGE_1MB: ::c_int = 20 << 26;
pub const SHM_HUGE_2MB: ::c_int = 21 << 26;
pub const SHM_HUGE_8MB: ::c_int = 23 << 26;
pub const SHM_HUGE_16MB: ::c_int = 24 << 26;
pub const SHM_HUGE_32MB: ::c_int = 25 << 26;
pub const SHM_HUGE_256MB: ::c_int = 28 << 26;
pub const SHM_HUGE_512MB: ::c_int = 29 << 26;
pub const SHM_HUGE_1GB: ::c_int = 30 << 26;
pub const SHM_HUGE_2GB: ::c_int = 31 << 26;
pub const SHM_HUGE_16GB: ::c_uint = 34 << 26;
pub type shmatt_t = ::c_ulong;
s! {
    pub struct shmid_ds {
        pub shm_perm: ::ipc64_perm,
        pub shm_segsz: ::size_t,
        pub shm_atime: ::time_t,
        pub shm_dtime: ::time_t,
        pub shm_ctime: ::time_t,
        pub shm_cpid: ::pid_t,
        pub shm_lpid: ::pid_t,
        pub shm_nattch: ::c_ulong,
    }
    pub struct shminfo {
        pub shmmax: ::c_ulong,
        pub shmmin: ::c_ulong,
        pub shmmni: ::c_ulong,
        pub shmseg: ::c_ulong,
        pub shmall: ::c_ulong,
        pub __unused: [::c_ulong; 4],
    }
}
extern "C" {
    pub fn shmat(__shmid: ::c_int, __shmaddr: *const ::c_void, __shmflg: ::c_int) -> *mut ::c_void;
    pub fn shmctl(__shmid: ::c_int, __cmd: ::c_int, __buf: *mut ::shmid_ds) -> ::c_int;
    pub fn shmdt(__shmaddr: *const ::c_void) -> ::c_int;
    pub fn shmget(__key: ::key_t, __size: ::size_t, __shmflg: ::c_int) -> ::c_int;
}

// sys/signal.h

// sys/signalfd.h
pub const SFD_CLOEXEC: ::c_int = O_CLOEXEC;
pub const SFD_NONBLOCK: ::c_int = O_NONBLOCK;
s! {
    pub struct signalfd_siginfo {
        pub ssi_signo: u32,
        pub ssi_errno: i32,
        pub ssi_code: i32,
        pub ssi_pid: u32,
        pub ssi_uid: u32,
        pub ssi_fd: i32,
        pub ssi_tid: u32,
        pub ssi_band: u32,
        pub ssi_overrun: u32,
        pub ssi_trapno: u32,
        pub ssi_status: i32,
        pub ssi_int: i32,
        pub ssi_ptr: u64,
        pub ssi_utime: u64,
        pub ssi_stime: u64,
        pub ssi_addr: u64,
        pub ssi_addr_lsb: u16,
        pub pad: [u8; 46],
    }
}
extern "C" {
    pub fn signalfd(__fd: ::c_int, __mask: *const ::sigset_t, __flags: ::c_int) -> ::c_int;
}

// sys/socket.h

// sys/stat.h
extern "C" {
    pub fn fstat64(__fd: ::c_int, __result: *mut ::stat) -> ::c_int;
    pub fn lstat64(__pathname: *const ::c_char, __buf: *mut ::stat) -> ::c_int;
    pub fn mkfifoat(__dirfd: ::c_int, __pathname: *const ::c_char, __mode: ::mode_t) -> ::c_int;
}

// sys/statfs.h
extern "C" {
    pub fn fstatfs64(__fd: ::c_int, __buf: *mut ::statfs64) -> ::c_int;
}

// sys/statvfs.h
extern "C" {
    pub fn statvfs64(__pathname: *const ::c_char, __buf: *mut ::statvfs64) -> ::c_int;
    pub fn fstatvfs64(__fd: ::c_int, __buf: *mut ::statvfs64) -> ::c_int;
}

// sys/swap.h
extern "C" {
    pub fn swapon(__path: *const ::c_char, __flags: ::c_int) -> ::c_int;
    pub fn swapoff(__path: *const ::c_char) -> ::c_int;
}

// sys/sysinfo.h
s! {
    pub struct sysinfo {
        pub uptime: ::c_long,
        pub loads: [::c_ulong; 3],
        pub totalram: ::c_ulong,
        pub freeram: ::c_ulong,
        pub sharedram: ::c_ulong,
        pub bufferram: ::c_ulong,
        pub totalswap: ::c_ulong,
        pub freeswap: ::c_ulong,
        pub procs: ::c_ushort,
        pub totalhigh: ::c_ulong,
        pub freehigh: ::c_ulong,
        pub mem_unit: ::c_uint,
        pub _f: [::c_char; 0],
    }
}
extern "C" {
    pub fn sysinfo(__info: *mut ::sysinfo) -> ::c_int;
    pub fn get_nprocs() -> ::c_int;
    pub fn get_nprocs_conf() -> ::c_int;
}

// sys/syslog.h

// sys/sysmacros.h

// sys/termios.h
pub const B0: ::speed_t = 0;
pub const B50: ::speed_t = 1;
pub const B75: ::speed_t = 2;
pub const B110: ::speed_t = 3;
pub const B134: ::speed_t = 4;
pub const B150: ::speed_t = 5;
pub const B200: ::speed_t = 6;
pub const B300: ::speed_t = 7;
pub const B600: ::speed_t = 8;
pub const B1200: ::speed_t = 9;
pub const B1800: ::speed_t = 10;
pub const B2400: ::speed_t = 11;
pub const B4800: ::speed_t = 12;
pub const B9600: ::speed_t = 13;
pub const B19200: ::speed_t = 14;
pub const B38400: ::speed_t = 15;
pub const B57600: ::speed_t = 0o010001;
pub const B115200: ::speed_t = 0o010002;
pub const B230400: ::speed_t = 0o010003;
pub const B460800: ::speed_t = 0o010004;
pub const B500000: ::speed_t = 0o010005;
pub const B576000: ::speed_t = 0o010006;
pub const B921600: ::speed_t = 0o010007;
pub const B1000000: ::speed_t = 0o010010;
pub const B1152000: ::speed_t = 0o010011;
pub const B1500000: ::speed_t = 0o010012;
pub const B2000000: ::speed_t = 0o010013;
pub const B2500000: ::speed_t = 0o010014;
pub const B3000000: ::speed_t = 0o010015;
pub const B3500000: ::speed_t = 0o010016;
pub const B4000000: ::speed_t = 0o010017;
pub const TCSANOW: ::c_int = 0;
pub const TCSADRAIN: ::c_int = 1;
pub const TCSAFLUSH: ::c_int = 2;
pub const TIOCM_DTR: ::c_int = 0x002;
pub const TIOCM_RTS: ::c_int = 0x004;
pub const TIOCSCTTY: ::c_ulong = 0x540E;
pub const TIOCGPGRP: ::c_int = 0x540F;
pub const TIOCSPGRP: ::c_int = 0x5410;
pub const TIOCGWINSZ: ::c_ulong = 0x5413;
pub const TIOCSWINSZ: ::c_ulong = 0x5414;
pub const TIOCGSID: ::c_int = 0x5429;

// sys/time.h
s! {
    pub struct timezone {
        pub tz_minuteswest: ::c_int,
        pub tz_dsttime: ::c_int,
    }
}
extern "C" {
    pub fn gettimeofday(__result: *mut ::timeval, __unused: *mut ::c_void) -> ::c_int;
    pub fn settimeofday(__result: *const ::timeval, __zone: *const ::timezone) -> ::c_int;
    pub fn timeradd(__a: *const ::timeval, __b: *const ::timeval, __res: *mut ::timeval);
    pub fn timersub(__a: *const ::timeval, __b: *const ::timeval, __res: *mut ::timeval);
    pub fn timerclear(__tvp: *mut ::timeval);
    pub fn timerisset(__tvp: *mut ::timeval) -> ::c_int;
    pub fn getitimer(__which: ::c_int, __curr_value: *mut ::itimerval) -> ::c_int;
    pub fn setitimer(
        __which: ::c_int,
        __new_value: *const ::itimerval,
        __old_value: *mut ::itimerval,
    ) -> ::c_int;
    pub fn timer_create(
        __clockid: ::clockid_t,
        __sevp: *mut ::sigevent,
        __timerid: *mut ::timer_t,
    ) -> ::c_int;
    pub fn timer_settime(
        __timerid: ::timer_t,
        __flags: ::c_int,
        __new_value: *const ::itimerspec,
        __old_value: *mut ::itimerspec,
    ) -> ::c_int;
    pub fn timer_gettime(__timerid: ::timer_t, __curr_value: *mut ::itimerspec) -> ::c_int;
    pub fn timer_delete(__timerid: ::timer_t) -> ::c_int;
}

// sys/timeb.h

// sys/timerfd.h
pub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;
pub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;
pub const TFD_TIMER_ABSTIME: ::c_int = 1;
pub const TFD_TIMER_CANCEL_ON_SET: ::c_int = 1 << 1;
extern "C" {
    pub fn timerfd_create(__clockid: ::c_int, __flags: ::c_int) -> ::c_int;
    pub fn timerfd_settime(
        __fd: ::c_int,
        __flags: ::c_int,
        __value: *const ::itimerspec,
        __oldvalue: *mut ::itimerspec,
    ) -> ::c_int;
    pub fn timerfd_gettime(__fd: ::c_int, __value: *mut ::itimerspec) -> ::c_int;
}

// sys/times.h
s! {
    pub struct tms {
        pub tms_utime: ::clock_t,
        pub tms_stime: ::clock_t,
        pub tms_cutime: ::clock_t,
        pub tms_cstime: ::clock_t,
    }
}

// sys/timex.h
pub const ADJ_OFFSET: ::c_int = 0x0001;
pub const ADJ_FREQUENCY: ::c_int = 0x0002;
pub const ADJ_MAXERROR: ::c_int = 0x0004;
pub const ADJ_ESTERROR: ::c_int = 0x0008;
pub const ADJ_STATUS: ::c_int = 0x0010;
pub const ADJ_TIMECONST: ::c_int = 0x0020;
pub const ADJ_TAI: ::c_int = 0x0080;
pub const ADJ_SETOFFSET: ::c_int = 0x0100;
pub const ADJ_MICRO: ::c_int = 0x1000;
pub const ADJ_NANO: ::c_int = 0x2000;
pub const ADJ_TICK: ::c_int = 0x4000;
pub const ADJ_OFFSET_SINGLESHOT: ::c_int = 0x8001;
pub const ADJ_OFFSET_SS_READ: ::c_int = 0xa001;
pub const STA_PLL: ::c_int = 0x0001;
pub const STA_PPSFREQ: ::c_int = 0x0002;
pub const STA_PPSTIME: ::c_int = 0x0004;
pub const STA_FLL: ::c_int = 0x0008;
pub const STA_INS: ::c_int = 0x0010;
pub const STA_DEL: ::c_int = 0x0020;
pub const STA_UNSYNC: ::c_int = 0x0040;
pub const STA_FREQHOLD: ::c_int = 0x0080;
pub const STA_PPSSIGNAL: ::c_int = 0x0100;
pub const STA_PPSJITTER: ::c_int = 0x0200;
pub const STA_PPSWANDER: ::c_int = 0x0400;
pub const STA_PPSERROR: ::c_int = 0x0800;
pub const STA_CLOCKERR: ::c_int = 0x1000;
pub const STA_NANO: ::c_int = 0x2000;
pub const STA_MODE: ::c_int = 0x4000;
pub const STA_CLK: ::c_int = 0x8000;
s! {
    pub struct timex {
        pub modes: ::c_int,
        pub offset: ::c_long,
        pub freq: ::c_long,
        pub maxerror: ::c_long,
        pub esterror: ::c_long,
        pub status: ::c_int,
        pub constant: ::c_long,
        pub precision: ::c_long,
        pub tolerance: ::c_long,
        pub time: ::timeval,
        pub tick: ::c_long,
        pub ppsfreq: ::c_long,
        pub jitter: ::c_long,
        pub shift: ::c_int,
        pub stabil: ::c_long,
        pub jitcnt: ::c_long,
        pub calcnt: ::c_long,
        pub errcnt: ::c_long,
        pub stbcnt: ::c_long,
        pub tai: ::c_int,
        pub __padding: [::c_int; 11],
    }
}
extern "C" {
    pub fn adjtimex(__buf: *mut ::timex) -> ::c_int;
    pub fn clock_adjtime(__clockid: ::clockid_t, __buf: *mut ::timex) -> ::c_int;
    pub fn ntp_adjtime(__buf: *mut ::timex) -> ::c_int;
}

// sys/types.h

// sys/ucontext.h

// sys/uio.h
extern "C" {
    pub fn preadv(
        __fd: ::c_int,
        __iov: *const ::iovec,
        __iovcnt: ::c_int,
        __offset: ::off_t,
    ) -> ::ssize_t;
    pub fn pwritev(
        __fd: ::c_int,
        __iov: *const ::iovec,
        __iovcnt: ::c_int,
        __offset: ::off_t,
    ) -> ::ssize_t;
}

// sys/un.h

// sys/utsname.h

// sys/vfs.h

// sys/vt.h

// sys/wait.h

// sys/xattr.h
extern "C" {
    pub fn setxattr(
        __path: *const ::c_char,
        __name: *const ::c_char,
        __val: *const ::c_void,
        __size: ::size_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn lsetxattr(
        __path: *const ::c_char,
        __name: *const ::c_char,
        __val: *const ::c_void,
        __size: ::size_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn fsetxattr(
        __fd: ::c_int,
        __name: *const ::c_char,
        __val: *const ::c_void,
        __size: ::size_t,
        __flags: ::c_int,
    ) -> ::c_int;
    pub fn getxattr(
        __path: *const ::c_char,
        __name: *const ::c_char,
        __val: *mut ::c_void,
        __size: ::size_t,
    ) -> ::ssize_t;
    pub fn lgetxattr(
        __path: *const ::c_char,
        __name: *const ::c_char,
        __val: *mut ::c_void,
        __size: ::size_t,
    ) -> ::ssize_t;
    pub fn fgetxattr(
        __fd: ::c_int,
        __name: *const ::c_char,
        __val: *mut ::c_void,
        __size: ::size_t,
    ) -> ::ssize_t;
    pub fn listxattr(__path: *const ::c_char, __list: *mut ::c_char, __size: ::size_t)
        -> ::ssize_t;
    pub fn llistxattr(
        __path: *const ::c_char,
        __list: *mut ::c_char,
        __size: ::size_t,
    ) -> ::ssize_t;
    pub fn flistxattr(__fd: ::c_int, __list: *mut ::c_char, __size: ::size_t) -> ::ssize_t;
    pub fn removexattr(__path: *const ::c_char, __name: *const ::c_char) -> ::c_int;
    pub fn lremovexattr(__path: *const ::c_char, __name: *const ::c_char) -> ::c_int;
    pub fn fremovexattr(__fd: ::c_int, __name: *const ::c_char) -> ::c_int;
}

// termios.h

// time.h

// uchar.h
pub type char16_t = ::c_ushort;
pub type char32_t = ::c_uint;
extern "C" {
    pub fn c32rtomb(__pmb: *mut ::c_char, __c32: ::char32_t, __ps: *mut ::mbstate_t) -> ::size_t;
    pub fn mbrtoc32(
        __pc32: *mut ::char32_t,
        __pmb: *const ::c_char,
        __max: ::size_t,
        __ps: *mut ::mbstate_t,
    ) -> ::size_t;
}

// ucontext.h
extern "C" {
    pub fn getcontext(__uctx: *mut ::ucontext_t) -> ::c_int;
    pub fn setcontext(__uctx: *const ::ucontext_t) -> ::c_int;
    pub fn makecontext(
        __uctx: *mut ::ucontext_t,
        __fn: ::Option<unsafe extern "C" fn() -> ::c_void>,
        __argc: ::c_int,
        ...
    );
    pub fn swapcontext(__uctx: *mut ::ucontext_t, __newctx: *const ::ucontext_t) -> ::c_int;
}

// unistd.h

// utmp.h
pub const EMPTY: ::c_int = 0;
pub const RUN_LVL: ::c_int = 1;
pub const BOOT_TIME: ::c_int = 2;
pub const NEW_TIME: ::c_int = 3;
pub const OLD_TIME: ::c_int = 4;
pub const INIT_PROCESS: ::c_int = 5;
pub const LOGIN_PROCESS: ::c_int = 6;
pub const USER_PROCESS: ::c_int = 7;
pub const DEAD_PROCESS: ::c_int = 8;
pub const ACCOUNTING: ::c_int = 9;
pub const UT_LINESIZE: ::c_int = 32;
pub const UT_NAMESIZE: ::c_int = 32;
pub const UT_HOSTSIZE: ::c_int = 256;
s! {
    pub struct exit_status {
        pub e_termination: ::c_short,
        pub e_exit: ::c_short,
    }
    pub struct utmp {
        pub ut_type: ::c_short,
        pub ut_pid: ::pid_t,
        pub ut_line: [::c_char; 32],
        pub ut_id: [::c_char; 4],
        pub ut_user: [::c_char; 32],
        pub ut_host: [::c_char; 256],
        pub ut_exit: ::exit_status,
        pub ut_session: ::c_long,
        pub ut_tv: ::timeval,
        pub ut_addr_v6: [i32; 4],
        pub __unused: [::c_char; 20],
    }
    pub struct lastlog {
        pub ll_time: ::time_t,
        pub ll_line: [::c_char; 32],
        pub ll_host: [::c_char; 256],
    }
}
extern "C" {
    pub fn setutent();
    pub fn getutent() -> *mut ::utmp;
    pub fn getutent_r(__buf: *mut ::utmp, __res: *mut *mut ::utmp) -> ::c_int;
    pub fn endutent();
    pub fn pututline(__line: *const ::utmp) -> *mut ::utmp;
    pub fn getutline(__line: *const ::utmp) -> *mut ::utmp;
    pub fn getutid(__id: *const ::utmp) -> *mut ::utmp;
    pub fn utmpname(__file: *const ::c_char) -> ::c_int;
}

// utmpx.h
s! {
    pub struct utmpx {
        pub ut_type: ::c_short,
        pub __ut_pad1: ::c_short,
        pub ut_pid: ::pid_t,
        pub ut_line: [::c_char; 32],
        pub ut_id: [::c_char; 4],
        pub ut_user: [::c_char; 32],
        pub ut_host: [::c_char; 256],
        pub ut_exit: anon_utmpx_line21,
        pub ut_session: ::c_int,
        pub __ut_pad2: ::c_int,
        pub ut_tv: ::timeval,
        pub ut_addr_v6: [::c_uint; 4],
        pub __unused: [::c_char; 20],
    }
    pub struct anon_utmpx_line21 {
        pub __e_termination: ::c_short,
        pub __e_exit: ::c_short,
    }
}
extern "C" {
    pub fn updwtmpx(__wtmp_file: *const ::c_char, __ut: *const ::utmpx);
    pub fn utmpxname(__file: *const ::c_char) -> ::c_int;
    pub fn pututxline(__line: *const ::utmpx) -> *mut ::utmpx;
    pub fn getutxent() -> *mut ::utmpx;
    pub fn getutxid(__id: *const ::utmpx) -> *mut ::utmpx;
    pub fn setutxent();
    pub fn endutxent();
}
